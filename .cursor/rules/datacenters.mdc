---
description: Guidelines for authoring cldctl datacenter configurations (datacenter.dc/hcl)
globs: "**/*.dc,**/datacenter.hcl,**/datacenters/**/*.dc,**/datacenters/**/*.hcl"
alwaysApply: false
---

# Datacenter Authoring Guidelines

Datacenters are platform engineer-focused infrastructure templates in HCL that define how component resources get fulfilled using IaC modules.

## File Structure

```hcl
# Variables for datacenter configuration
variable "cluster_name" {
  type        = string
  description = "Kubernetes cluster name"
  default     = "my-cluster"  # Optional
}

# Datacenter-level modules (shared across environments)
module "network" {
  plugin = "native"           # or "pulumi", "opentofu"
  build  = "./modules/network"
  inputs = {
    name = variable.cluster_name
  }
}

# Datacenter-level components (auto-deployed as dependencies)
component "myorg/stripe" {
  source = "latest"
  variables = {
    secret_key = variable.stripe_key
  }
}

# Environment configuration with hooks
environment {
  # Environment-level modules
  module "namespace" { ... }
  
  # Resource hooks
  database { ... }
  deployment { ... }
  service { ... }
  route { ... }
}
```

## Hook Types

Each hook handles a component resource type:

| Hook | Purpose | Required Outputs |
|------|---------|-----------------|
| `database` | Provision databases | `host`, `port`, `url`, `username`, `password`; optional nested: `read`, `write` (auto-populated from top-level if omitted) |
| `task` | One-shot jobs (e.g., migrations) | `id` |
| `bucket` | Object storage | `endpoint`, `bucket`, `accessKeyId`, `secretAccessKey` |
| `encryptionKey` | Encryption keys | RSA/ECDSA: `privateKey`, `publicKey`, `privateKeyBase64`, `publicKeyBase64`; Symmetric: `key`, `keyBase64` |
| `smtp` | Email sending | `host`, `port`, `username`, `password` |
| `deployment` | Container workloads | `id` |
| `function` | Serverless functions | `id`, `endpoint` |
| `service` | Internal networking | `host`, `port`, `url` |
| `route` | External routing | `url`, `host`, `port` |
| `dockerBuild` | Build images | `image` |
| `cronjob` | Scheduled tasks | `id` |
| `observability` | OpenTelemetry config | `endpoint`, `protocol`, `attributes`; optional: `query_type`, `query_endpoint`, `dashboard_url` |
| `databaseUser` | Per-consumer DB credentials (implicit; only created when hook is defined) | `host`, `port`, `url` |
| `networkPolicy` | Inter-service traffic control (implicit; only created when hook is defined) | none |

## Expression Context

| Expression | Description |
|------------|-------------|
| `variable.<name>` | Datacenter variables |
| `environment.name` | Current environment name |
| `node.name` | Resource name (in hooks) |
| `node.type` | Resource type: deployment, database, function, service, route, etc. |
| `node.component` | Component the resource belongs to |
| `node.inputs.<field>` | Resource input values |
| `module.<name>.<output>` | Module output values |

## Datacenter Components

Declare shared components at the datacenter level for automatic dependency resolution. When a component in an environment depends on a datacenter-declared component, the engine automatically deploys it with the configured source and variables.

```hcl
variable "stripe_secret_key" {
  type      = string
  sensitive = true
}

component "myorg/stripe" {
  source = "latest"
  variables = {
    secret_key = variable.stripe_secret_key
  }
}
```

- Components are **not** deployed at the datacenter level -- they are deployed into environments on demand
- Variable values can reference `variable.*` and `module.*.*`
- Datacenter component values take priority over interactive prompts but not over explicitly provided values

## Hook Pattern

```hcl
database {
  # Conditional - which database types this hook handles
  when = element(split(":", node.inputs.type), 0) == "postgres"
  
  module "postgres" {
    plugin = "native"
    build  = "./modules/docker-postgres"
    inputs = {
      name     = "${environment.name}-${node.component}-${node.name}"
      version  = coalesce(try(element(split(":", node.inputs.type), 1), null), "16")
      database = node.name
    }
  }
  
  # Map module outputs to hook outputs
  outputs = {
    host     = module.postgres.host
    port     = module.postgres.port
    url      = module.postgres.url
    username = module.postgres.username
    password = module.postgres.password
  }
}
```

### Multi-Module Hooks and Nested Outputs

Hooks can define multiple modules. All modules are executed in order, and later modules
can reference earlier modules' outputs via `module.<name>.<output>`. Outputs can include
nested objects (e.g., `read`/`write` for database read/write endpoint separation):

```hcl
database {
  module "primary" { ... }
  module "replica" { ... }

  outputs = {
    host = module.primary.host
    url  = module.primary.url
    # ...

    read = {
      host = module.replica.host
      url  = module.replica.url
    }
    write = {
      host = module.primary.host
      url  = module.primary.url
    }
  }
}
```

## Deployment Routing Pattern

Deployments support three modes via `when` conditions:

```hcl
# Container-based (image present)
deployment {
  when = node.inputs.image != null
  module "container" { ... }
}

# VM-based (runtime present, no image)
deployment {
  when = node.inputs.runtime != null && node.inputs.image == null
  module "vm" {
    plugin = "opentofu"
    build  = "./modules/ec2-vm"     # or do-droplet, gce-instance
    inputs = merge(node.inputs, { ... })
  }
}

# Process-based (no image, no runtime - local dev)
deployment {
  when = node.inputs.image == null && node.inputs.runtime == null
  module "process" { ... }
}
```

The `node.inputs.runtime` object contains: `language`, `os`, `arch`, `packages`, `setup`.

## Observability Hook Pattern

The `observability` hook provides OpenTelemetry configuration to workloads. Datacenters can
provide `attributes` alongside `endpoint` and `protocol`. The engine merges datacenter
attributes with component attributes and auto-generated ones (`service.namespace`,
`deployment.environment`) into a single `${{ observability.attributes }}` expression.

```hcl
# Simple: static endpoint with datacenter-level attributes
observability {
  outputs = {
    endpoint = "http://localhost:4318"
    protocol = "http/protobuf"
    attributes = {
      cloud.provider = "local"
    }
  }
}

# Production: provision a shared collector
environment {
  module "otel_collector" {
    plugin = "native"
    build  = "./modules/otel-collector"
    inputs = {
      name = "${environment.name}-otel"
    }
  }

  observability {
    outputs = {
      endpoint = module.otel_collector.endpoint
      protocol = module.otel_collector.protocol
      attributes = {
        cloud.provider = "aws"
        cloud.region   = variable.region
      }
    }
  }
}
```

`node.inputs` for observability hooks: `inject` (bool), `attributes` (map).

## IaC Plugins

- `native` - Lightweight execution (Docker, processes) for local dev
- `pulumi` - Pulumi IaC modules
- `opentofu` - OpenTofu/Terraform modules

## Built-in Functions

- `coalesce(a, b)` - First non-null value
- `merge(map1, map2)` - Merge maps
- `tostring(value)` - Convert to string
- `format(fmt, args...)` - String formatting

## Documentation Sync

When making changes to the datacenter schema (hooks, expressions, module system, variables):

1. Update the relevant hook reference page(s) in `docs/datacenters/` (e.g., `database-hook.mdx`, `deployment-hook.mdx`)
2. Update any affected guides in `docs/guides/datacenters/`
3. Update official templates in `official-templates/` if applicable
4. Update `AGENTS.md` datacenter authoring sections and hook types table
5. Update this file (`.cursor/rules/datacenters.mdc`) with new hook patterns or expressions

See `AGENTS.md` > "Keeping Documentation In Sync" for the full checklist.
