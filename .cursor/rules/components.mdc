---
description: Guidelines for authoring arcctl component configurations (architect.yml)
globs: "**/architect.yml,**/architect.yaml,**/components/**/*.yml,**/components/**/*.yaml"
alwaysApply: false
---

# Component Authoring Guidelines

Components are developer-focused application bundles in `architect.yml` files that describe what an application needs without specifying infrastructure details.

## File Structure

```yaml
# Component name comes from the OCI tag at build time
# README.md (if present) is bundled into the artifact for documentation
# Use `extends: ./base.yml` to inherit from another component file

# Build artifacts (optional)
builds: map<string, Build>         # Docker image build configs

# Resources
databases: map<string, Database>
buckets: map<string, Bucket>
deployments: map<string, Deployment>
functions: map<string, Function>
services: map<string, Service>
routes: map<string, Route>
cronjobs: map<string, Cronjob>

# Configuration
variables: map<string, Variable>
dependencies: map<string, string>  # key: reference name, value: repo:tag
```

## Expression Syntax

Use `${{ ... }}` to reference values:

```yaml
environment:
  DATABASE_URL: ${{ databases.main.url }}
  REDIS_URL: ${{ databases.cache.url }}
  LOG_LEVEL: ${{ variables.log_level }}
  API_URL: ${{ services.api.url }}
```

## Available References

| Expression | Description |
|------------|-------------|
| `builds.<name>.image` | Built Docker image tag |
| `databases.<name>.url` | Database connection URL |
| `databases.<name>.host` | Database host |
| `databases.<name>.port` | Database port |
| `buckets.<name>.endpoint` | Bucket endpoint |
| `services.<name>.url` | Service URL |
| `observability.endpoint` | OTel collector endpoint (from datacenter) |
| `observability.protocol` | OTLP protocol (from datacenter) |
| `observability.attributes` | Merged resource attributes (auto + datacenter + component) |
| `variables.<name>` | Variable value |
| `dependencies.<name>.<output>` | Dependency outputs |

## Functions

Functions use a discriminated union: either `src` (source-based) or `container` (container-based).

### Source-Based Function (Recommended)

```yaml
functions:
  web:
    src:
      path: ./web
      framework: nextjs  # Optional - auto-detected
    environment:
      DATABASE_URL: ${{ databases.main.url }}
    memory: "1024Mi"
```

Most `src` fields are optional and auto-detected:
- `language`: Detected from package.json, go.mod, pyproject.toml
- `framework`: Detected from dependencies (next, fastapi, gin, etc.)
- `install`, `dev`, `build`, `start`: Detected from scripts/Makefile

### Container-Based Function

```yaml
functions:
  api:
    container:
      build:
        context: ./api
        dockerfile: Dockerfile
    port: 8080
```

Or with a pre-built image:

```yaml
functions:
  api:
    container:
      image: ghcr.io/myorg/api:v1.0.0
    port: 8080
```

## Common Patterns

### Database with Migrations

```yaml
databases:
  main:
    type: postgres:^15
    migrations:
      build:
        context: ./migrations
      command: ["npm", "run", "migrate"]
```

### Top-level Builds

Docker builds are defined at the top level. Deployments reference them via expressions:

```yaml
builds:
  api:
    context: ./api
    dockerfile: Dockerfile    # optional, defaults to "Dockerfile"
    target: production        # optional multi-stage target
    args:                     # optional build args
      NODE_ENV: production

deployments:
  api:
    image: ${{ builds.api.image }}
    environment:
      DATABASE_URL: ${{ databases.main.url }}
    cpu: "0.5"
    memory: "512Mi"
    replicas: 2
    liveness_probe:
      path: /health
      port: 8080
```

### Process-based Deployment (Dev Mode)

Deployments without `image` run as host processes (no Docker required):

```yaml
deployments:
  api:
    command: ["npm", "run", "dev"]
    workingDirectory: ./backend  # optional, defaults to architect.yml dir
    environment:
      DATABASE_URL: ${{ databases.main.url }}
```

### VM-based Deployment with Runtime

Use `runtime` for deployments that run on VMs (EC2, Droplets, GCE).
Supports string shorthand (`runtime: node:20`) or full object:

```yaml
deployments:
  worker:
    runtime:
      language: node:20          # Required. Language and version
      os: linux                  # Optional (linux, windows)
      arch: amd64                # Optional (amd64, arm64)
      packages:                  # Optional. System-level dependencies
        - ffmpeg
      setup:                     # Optional. Provisioning commands
        - npm ci --production
    command: ["node", "dist/worker.js"]
    cpu: "2"
    memory: "4Gi"
    replicas: 5
```

Datacenters route deployments with `runtime` (and no `image`) to VM provisioning hooks.

### Component Extends (Dev/Prod Pattern)

Use `extends` to inherit from a base component and override specific fields:

```yaml
# architect.yml (dev base - process-based)
deployments:
  api:
    command: ["npm", "run", "dev"]
    environment:
      DATABASE_URL: ${{ databases.main.url }}
```

```yaml
# architect.prod.yml (production - extends dev)
extends: ./architect.yml

builds:
  api:
    context: .

deployments:
  api:
    image: ${{ builds.api.image }}
    command: ["npm", "start"]
```

### Service with Route

```yaml
services:
  api:
    deployment: api
    port: 8080

routes:
  main:
    type: http
    rules:
      - matches:
          - path:
              type: PathPrefix
              value: /api
        backendRefs:
          - service: api
            port: 8080
```

### Route Pointing to Function

```yaml
functions:
  web:
    src:
      path: ./web
      framework: nextjs

routes:
  main:
    type: http
    function: web  # Simplified form - routes can point directly to functions
```

## Observability (OpenTelemetry)

The optional `observability` block declares OTel preferences. Two modes:

### Expression-Only (default)
Wire `${{ observability.* }}` expressions into env vars manually:
```yaml
observability:
  attributes:
    team: backend

deployments:
  api:
    environment:
      OTEL_EXPORTER_OTLP_ENDPOINT: ${{ observability.endpoint }}
      OTEL_EXPORTER_OTLP_PROTOCOL: ${{ observability.protocol }}
      OTEL_RESOURCE_ATTRIBUTES: ${{ observability.attributes }}
```

`${{ observability.attributes }}` returns merged `key=value,...` from: auto-generated (`service.namespace`, `deployment.environment`) + datacenter hook attributes + component attributes.

### Auto-Inject
Set `inject: true` to have the engine inject OTEL_* env vars into all workloads automatically:
```yaml
observability:
  inject: true
  logs: true
  traces: true
  metrics: false
  attributes:
    team: payments
```

Auto-injected vars: `OTEL_EXPORTER_OTLP_ENDPOINT`, `OTEL_EXPORTER_OTLP_PROTOCOL`, `OTEL_SERVICE_NAME`, `OTEL_LOGS_EXPORTER`, `OTEL_TRACES_EXPORTER`, `OTEL_METRICS_EXPORTER`, `OTEL_RESOURCE_ATTRIBUTES`. Component-declared values are never overwritten.

## Supported Database Types

- `postgres:^15` - PostgreSQL with semver version
- `mysql:^8` - MySQL
- `mariadb:^10` - MariaDB
- `mongodb:^6` - MongoDB
- `redis` - Redis (no version)
- `cockroachdb:^23` - CockroachDB distributed SQL
- `clickhouse:^24` - ClickHouse OLAP database
