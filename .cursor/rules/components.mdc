---
description: Guidelines for authoring cldctl component configurations (cld.yml)
globs: "**/cld.yml,**/cld.yaml,**/components/**/*.yml,**/components/**/*.yaml"
alwaysApply: false
---

# Component Authoring Guidelines

Components are developer-focused application bundles in `cld.yml` files that describe what an application needs without specifying infrastructure details.

## File Structure

```yaml
# Component name comes from the OCI tag at build time
# README.md (if present) is bundled into the artifact for documentation
# Use `extends: ./base.yml` to inherit from another component file

# Build artifacts (optional)
builds: map<string, Build>         # Docker image build configs

# Resources
databases: map<string, Database>
buckets: map<string, Bucket>
ports: map<string, true | Port>      # Dynamic port allocations (opt-in)
deployments: map<string, Deployment>
functions: map<string, Function>
services: map<string, Service>       # Service port supports int or ${{ ports.<name>.port }}
routes: map<string, Route>
cronjobs: map<string, Cronjob>

# Configuration
variables: map<string, Variable>
dependencies: map<string, string | Dependency>  # string shorthand or object with source + optional
```

## Expression Syntax

Use `${{ ... }}` to reference values:

```yaml
environment:
  DATABASE_URL: ${{ databases.main.url }}
  REDIS_URL: ${{ databases.cache.url }}
  LOG_LEVEL: ${{ variables.log_level }}
  API_URL: ${{ services.api.url }}
```

## Available References

| Expression | Description |
|------------|-------------|
| `builds.<name>.image` | Built Docker image tag |
| `databases.<name>.url` | Database connection URL |
| `databases.<name>.host` | Database host |
| `databases.<name>.port` | Database port |
| `buckets.<name>.endpoint` | Bucket endpoint |
| `ports.<name>.port` | Allocated port number |
| `services.<name>.url` | Service URL |
| `observability.endpoint` | OTel collector endpoint (from datacenter) |
| `observability.protocol` | OTLP protocol (from datacenter) |
| `observability.attributes` | Merged resource attributes (auto + datacenter + component) |
| `variables.<name>` | Variable value |
| `dependencies.<name>.<output>` | Dependency outputs |

## Functions

Functions use a discriminated union: either `src` (source-based) or `container` (container-based).

### Source-Based Function (Recommended)

```yaml
functions:
  web:
    src:
      path: ./web
      framework: nextjs  # Optional - auto-detected
    environment:
      DATABASE_URL: ${{ databases.main.url }}
    memory: "1024Mi"
```

Most `src` fields are optional and auto-detected:
- `language`: Detected from package.json, go.mod, pyproject.toml
- `framework`: Detected from dependencies (next, fastapi, gin, etc.)
- `install`, `dev`, `build`, `start`: Detected from scripts/Makefile

### Container-Based Function

```yaml
functions:
  api:
    container:
      build:
        context: ./api
        dockerfile: Dockerfile
    port: 8080
```

Or with a pre-built image:

```yaml
functions:
  api:
    container:
      image: ghcr.io/myorg/api:v1.0.0
    port: 8080
```

## Common Patterns

### Database with Migrations (Docker Image)

```yaml
builds:
  migrations:
    context: ./migrations

databases:
  main:
    type: postgres:^15
    migrations:
      image: ${{ builds.migrations.image }}
      command: ["npm", "run", "migrate"]
```

### Database with Migrations (Process-based)

```yaml
databases:
  main:
    type: postgres:^15
    migrations:
      runtime: node:20
      command: ["npx", "prisma", "migrate", "deploy"]
```

### Top-level Builds

Docker builds are defined at the top level. Deployments and migrations reference them via expressions:

```yaml
builds:
  api:
    context: ./api
    dockerfile: Dockerfile    # optional, defaults to "Dockerfile"
    target: production        # optional multi-stage target
    args:                     # optional build args
      NODE_ENV: production

deployments:
  api:
    image: ${{ builds.api.image }}
    environment:
      DATABASE_URL: ${{ databases.main.url }}
    cpu: "0.5"
    memory: "512Mi"
    replicas: 2
    liveness_probe:
      path: /health
      port: 8080
```

### Process-based Deployment (Dev Mode)

Deployments without `image` run as host processes (no Docker required):

```yaml
deployments:
  api:
    command: ["npm", "run", "dev"]
    workingDirectory: ./backend  # optional, defaults to cld.yml dir
    environment:
      DATABASE_URL: ${{ databases.main.url }}
```

### VM-based Deployment with Runtime

Use `runtime` for deployments that run on VMs (EC2, Droplets, GCE).
Supports string shorthand (`runtime: node:20`) or full object:

```yaml
deployments:
  worker:
    runtime:
      language: node:20          # Required. Language and version
      os: linux                  # Optional (linux, windows)
      arch: amd64                # Optional (amd64, arm64)
      packages:                  # Optional. System-level dependencies
        - ffmpeg
      setup:                     # Optional. Provisioning commands
        - npm ci --production
    command: ["node", "dist/worker.js"]
    cpu: "2"
    memory: "4Gi"
    replicas: 5
```

Datacenters route deployments with `runtime` (and no `image`) to VM provisioning hooks.

### Component Extends (Dev/Prod Pattern)

Use `extends` to inherit from a base component and override specific fields:

```yaml
# cld.yml (dev base - process-based)
deployments:
  api:
    command: ["npm", "run", "dev"]
    environment:
      DATABASE_URL: ${{ databases.main.url }}
```

```yaml
# cld.prod.yml (production - extends dev)
extends: ./cld.yml

builds:
  api:
    context: .

deployments:
  api:
    image: ${{ builds.api.image }}
    command: ["npm", "start"]
```

### Dynamic Port Allocation

Use `ports` for applications that should listen on a platform-assigned port:

```yaml
ports:
  api:
    description: "API server port"

deployments:
  api:
    command: ["node", "server.js"]
    environment:
      PORT: ${{ ports.api.port }}

services:
  api:
    deployment: api
    port: ${{ ports.api.port }}
```

Fixed-port applications (like Inngest on 8288) don't need `ports` â€” set the port directly on the service.

### Service with Route

```yaml
services:
  api:
    deployment: api
    port: 8080

routes:
  main:
    type: http
    rules:
      - matches:
          - path:
              type: PathPrefix
              value: /api
        backendRefs:
          - service: api
```

### Route Pointing to Function

```yaml
functions:
  web:
    src:
      path: ./web
      framework: nextjs

routes:
  main:
    type: http
    function: web  # Simplified form - routes can point directly to functions
```

## Observability (OpenTelemetry)

The optional `observability` block declares OTel preferences. Two modes:

### Expression-Only (default)
Wire `${{ observability.* }}` expressions into env vars manually:
```yaml
observability:
  attributes:
    team: backend

deployments:
  api:
    environment:
      OTEL_EXPORTER_OTLP_ENDPOINT: ${{ observability.endpoint }}
      OTEL_EXPORTER_OTLP_PROTOCOL: ${{ observability.protocol }}
      OTEL_RESOURCE_ATTRIBUTES: ${{ observability.attributes }}
```

`${{ observability.attributes }}` returns merged `key=value,...` from: auto-generated (`service.namespace`, `deployment.environment`) + datacenter hook attributes + component attributes.

### Auto-Inject
Set `inject: true` to have the engine inject OTEL_* env vars into all workloads automatically:
```yaml
observability:
  inject: true
  attributes:
    team: payments
```

Auto-injected vars: `OTEL_EXPORTER_OTLP_ENDPOINT`, `OTEL_EXPORTER_OTLP_PROTOCOL`, `OTEL_SERVICE_NAME`, `OTEL_LOGS_EXPORTER` (`otlp`), `OTEL_TRACES_EXPORTER` (`otlp`), `OTEL_METRICS_EXPORTER` (`otlp`), `OTEL_RESOURCE_ATTRIBUTES`. All exporters default to `otlp`. To disable a specific signal, set e.g. `OTEL_METRICS_EXPORTER: none` in your environment block. Component-declared values are never overwritten.

### Viewing Logs

`cldctl logs` requires observability to be enabled in the component and the datacenter's observability hook to provide `query_type` and `query_endpoint` outputs. The local Docker datacenter uses Loki (backed by `grafana/otel-lgtm`). Container stdout is automatically forwarded to the OTel collector via Docker's fluentd logging driver, so even applications without OTel SDK instrumentation have queryable logs.

```bash
cldctl logs -e staging                            # All logs in the environment
cldctl logs -e staging my-app                     # Logs from one component
cldctl logs -e staging my-app/deployment          # All deployments in a component
cldctl logs -e staging my-app/deployment/api -f   # Stream a specific deployment
cldctl observability dashboard -e staging         # Open Grafana (or other UI) in browser
```

## Supported Database Types

- `postgres:^15` - PostgreSQL with semver version
- `mysql:^8` - MySQL
- `mariadb:^10` - MariaDB
- `mongodb:^6` - MongoDB
- `redis` - Redis (no version)
- `cockroachdb:^23` - CockroachDB distributed SQL
- `clickhouse:^24` - ClickHouse OLAP database

## Documentation Sync

When making changes to the component schema (fields, expressions, resource types, validation):

1. Update the relevant reference page(s) in `docs/components/` (e.g., `deployments.mdx`, `functions.mdx`, `databases.mdx`)
2. Update any affected guides in `docs/guides/components/`
3. Update example configs in `examples/components/` if applicable
4. Update `AGENTS.md` component authoring sections and expression references
5. Update this file (`.cursor/rules/components.mdc`) with new patterns or fields

See `AGENTS.md` > "Keeping Documentation In Sync" for the full checklist.
