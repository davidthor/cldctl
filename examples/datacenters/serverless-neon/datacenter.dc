# Example: Serverless datacenter with Neon PostgreSQL
# Uses serverless providers for maximum scalability and pay-per-use pricing
# Neon for PostgreSQL, Upstash for Redis, Cloudflare R2 for storage

variable "neon_api_key" {
  description = "Neon API key"
  type        = string
  sensitive   = true
}

variable "neon_project_id" {
  description = "Neon project ID"
  type        = string
}

variable "upstash_email" {
  description = "Upstash account email"
  type        = string
}

variable "upstash_api_key" {
  description = "Upstash API key"
  type        = string
  sensitive   = true
}

variable "cloudflare_account_id" {
  description = "Cloudflare account ID"
  type        = string
}

variable "cloudflare_api_token" {
  description = "Cloudflare API token"
  type        = string
  sensitive   = true
}

variable "domain" {
  description = "Base domain for environments"
  type        = string
  default     = "app.example.com"
}

environment {
  # Create a Neon branch per environment (instant, zero-cost when idle)
  module "neon_branch" {
    when  = anytrue([for n in environment.nodes : element(split(":", n.inputs.type), 0) == "postgres" if n.type == "database"])
    build = "./modules/neon-branch"
    inputs = {
      project_id  = variable.neon_project_id
      branch_name = environment.name
      api_key     = variable.neon_api_key
    }
  }

  # Create Upstash Redis database per environment
  module "upstash_redis" {
    when  = anytrue([for n in environment.nodes : element(split(":", n.inputs.type), 0) == "redis" if n.type == "database"])
    build = "./modules/upstash-redis"
    inputs = {
      name    = environment.name
      region  = "us-east-1"
      email   = variable.upstash_email
      api_key = variable.upstash_api_key
    }
  }

  # Cloudflare Workers namespace
  module "cf_namespace" {
    build = "./modules/cf-workers-namespace"
    inputs = {
      name       = environment.name
      account_id = variable.cloudflare_account_id
      api_token  = variable.cloudflare_api_token
    }
  }

  # DNS configuration
  module "cf_dns" {
    build = "./modules/cf-dns"
    inputs = {
      zone       = variable.domain
      subdomain  = environment.name
      account_id = variable.cloudflare_account_id
      api_token  = variable.cloudflare_api_token
    }
  }

  # Resource hooks
  database {
    when = element(split(":", node.inputs.type), 0) == "postgres"

    module "neon_database" {
      build = "./modules/serverless-database"
      inputs = {
        name              = node.name
        type              = element(split(":", node.inputs.type), 0)
        version           = try(element(split(":", node.inputs.type), 1), null)
        environment       = environment.name
        neon_project_id   = variable.neon_project_id
        neon_branch_id    = module.neon_branch.branch_id
        neon_api_key      = variable.neon_api_key
      }
    }

    outputs = {
      host     = module.neon_database.host
      port     = module.neon_database.port
      database = module.neon_database.database
      url      = module.neon_database.url
    }
  }

  database {
    when = element(split(":", node.inputs.type), 0) == "redis"

    module "redis_database" {
      build = "./modules/upstash-database"
      inputs = {
        name                = node.name
        upstash_database_id = module.upstash_redis.database_id
        upstash_api_key     = variable.upstash_api_key
      }
    }

    outputs = {
      host     = module.redis_database.host
      port     = module.redis_database.port
      database = module.redis_database.database
      url      = module.redis_database.url
    }
  }

  bucket {
    module "r2_bucket" {
      build = "./modules/cloudflare-r2"
      inputs = {
        name       = "${environment.name}-${node.name}"
        account_id = variable.cloudflare_account_id
        api_token  = variable.cloudflare_api_token
        versioning = node.inputs.versioning
        public     = node.inputs.public
      }
    }

    outputs = {
      endpoint        = module.r2_bucket.endpoint
      bucket          = module.r2_bucket.bucket_name
      region          = "auto"
      accessKeyId     = module.r2_bucket.access_key_id
      secretAccessKey = module.r2_bucket.secret_access_key
    }
  }

  # Convert deployments to Cloudflare Workers (containers not supported)
  deployment {
    module "worker" {
      build = "./modules/cf-worker"
      inputs = {
        name        = node.name
        namespace   = environment.name
        image       = node.inputs.image
        environment = node.inputs.environment
        account_id  = variable.cloudflare_account_id
        api_token   = variable.cloudflare_api_token
      }
    }

    outputs = {
      id = module.worker.worker_id
    }
  }

  function {
    module "cf_function" {
      build = "./modules/cf-worker"
      inputs = {
        name        = node.name
        namespace   = environment.name
        image       = node.inputs.image
        framework   = node.inputs.framework
        environment = node.inputs.environment
        timeout     = node.inputs.timeout
        account_id  = variable.cloudflare_account_id
        api_token   = variable.cloudflare_api_token
      }
    }

    outputs = {
      id       = module.cf_function.worker_id
      endpoint = module.cf_function.url
    }
  }

  service {
    module "service_binding" {
      build = "./modules/cf-service-binding"
      inputs = {
        name        = node.name
        target      = node.inputs.target
        target_type = node.inputs.target_type
        namespace   = environment.name
        account_id  = variable.cloudflare_account_id
        api_token   = variable.cloudflare_api_token
      }
    }

    outputs = {
      host = module.service_binding.worker_hostname
      port = 443
      url  = module.service_binding.url
    }
  }

  ingress {
    module "worker_route" {
      build = "./modules/cf-worker-route"
      inputs = {
        name       = node.name
        namespace  = environment.name
        type       = node.inputs.type
        rules      = node.inputs.rules
        internal   = node.inputs.internal
        hostnames  = node.inputs.hostnames
        domain     = "${environment.name}.${variable.domain}"
        account_id = variable.cloudflare_account_id
        api_token  = variable.cloudflare_api_token
      }
    }

    outputs = {
      url      = "https://${environment.name}.${variable.domain}"
      hosts    = ["${environment.name}.${variable.domain}"]
      protocol = "https"
      host     = "${environment.name}.${variable.domain}"
      port     = 443
    }
  }

  cronjob {
    module "cron_trigger" {
      build = "./modules/cf-cron-trigger"
      inputs = {
        name          = node.name
        namespace     = environment.name
        schedule      = node.inputs.schedule
        worker_name   = node.inputs.target_worker
        account_id    = variable.cloudflare_account_id
        api_token     = variable.cloudflare_api_token
      }
    }

    outputs = {
      id = module.cron_trigger.trigger_id
    }
  }

  databaseUser {
    when = element(split(":", node.inputs.type), 0) == "postgres"

    module "neon_role" {
      build = "./modules/neon-role"
      inputs = {
        branch_id  = module.neon_branch.branch_id
        project_id = variable.neon_project_id
        role_name  = node.inputs.username
        database   = node.inputs.database
        api_key    = variable.neon_api_key
      }
    }

    outputs = {
      username = module.neon_role.role_name
      password = module.neon_role.password
      url      = module.neon_role.connection_url
    }
  }

  secret {
    module "worker_secret" {
      build = "./modules/cf-worker-secret"
      inputs = {
        name       = node.name
        namespace  = environment.name
        data       = node.inputs.data
        account_id = variable.cloudflare_account_id
        api_token  = variable.cloudflare_api_token
      }
    }

    outputs = {
      id = module.worker_secret.secret_id
    }
  }

  dockerBuild {
    # Cloudflare Workers use a different build process
    module "worker_build" {
      build = "./modules/cf-worker-build"
      inputs = {
        context    = node.inputs.context
        dockerfile = node.inputs.dockerfile
        framework  = node.inputs.framework
      }
    }

    outputs = {
      image = module.worker_build.worker_script
    }
  }
}
