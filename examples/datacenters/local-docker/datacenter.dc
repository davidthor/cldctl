# Local Docker Datacenter
# A lightweight datacenter for local development using the native plugin.
# Uses Docker for databases and deployments, runs functions as local processes.
# Optimized for fast startup with minimal overhead.

variable "network_name" {
  description = "Docker network name for service communication"
  type        = string
  default     = "arcctl-local"
}

variable "host" {
  description = "Host for local services"
  type        = string
  default     = "localhost"
}

variable "base_port" {
  description = "Base port for auto-assigned ports"
  type        = number
  default     = 8000
}

# Create a shared Docker network for all environments
module "network" {
  plugin = "native"
  build  = "./modules/docker-network"
  inputs = {
    name = variable.network_name
  }
}

environment {
  # Database hook - PostgreSQL
  database {
    when = element(split(":", node.inputs.type), 0) == "postgres"
    
    module "postgres" {
      plugin = "native"
      build  = "./modules/docker-postgres"
      inputs = {
        name     = "${environment.name}-${node.component}-${node.name}"
        version  = coalesce(try(element(split(":", node.inputs.type), 1), null), "16")
        database = node.name
        network  = variable.network_name
      }
    }
    
    outputs = {
      host     = module.postgres.host
      port     = module.postgres.port
      database = module.postgres.database
      username = module.postgres.username
      password = module.postgres.password
      url      = module.postgres.url
    }
  }
  
  # Database hook - MySQL
  database {
    when = element(split(":", node.inputs.type), 0) == "mysql"
    
    module "mysql" {
      plugin = "native"
      build  = "./modules/docker-mysql"
      inputs = {
        name     = "${environment.name}-${node.component}-${node.name}"
        version  = coalesce(try(element(split(":", node.inputs.type), 1), null), "8")
        database = node.name
        network  = variable.network_name
      }
    }
    
    outputs = {
      host     = module.mysql.host
      port     = module.mysql.port
      database = module.mysql.database
      username = module.mysql.username
      password = module.mysql.password
      url      = module.mysql.url
    }
  }
  
  # Database hook - Redis
  database {
    when = element(split(":", node.inputs.type), 0) == "redis"
    
    module "redis" {
      plugin = "native"
      build  = "./modules/docker-redis"
      inputs = {
        name    = "${environment.name}-${node.component}-${node.name}"
        version = coalesce(try(element(split(":", node.inputs.type), 1), null), "7")
        network = variable.network_name
      }
    }
    
    outputs = {
      host     = module.redis.host
      port     = module.redis.port
      database = "0"
      url      = module.redis.url
    }
  }
  
  # Task hook - run one-time containers (e.g., database migrations)
  task {
    module "task" {
      plugin = "native"
      build  = "./modules/docker-exec"
      inputs = {
        name        = "${environment.name}-${node.component}-${node.name}"
        image       = node.inputs.image
        command     = node.inputs.command
        network     = variable.network_name
        environment = node.inputs.environment
      }
    }
    
    outputs = {
      id     = module.task.container_id
      status = module.task.exit_code == 0 ? "success" : "failed"
    }
  }
  
  # Bucket hook - use MinIO for S3-compatible storage
  bucket {
    module "minio" {
      plugin = "native"
      build  = "./modules/docker-bucket"
      inputs = {
        name       = "${environment.name}-${node.component}-${node.name}"
        versioning = node.inputs.versioning
        public     = node.inputs.public
        network    = variable.network_name
      }
    }
    
    outputs = {
      endpoint        = module.minio.endpoint
      bucket          = module.minio.bucket
      region          = module.minio.region
      accessKeyId     = module.minio.access_key_id
      secretAccessKey = module.minio.secret_access_key
    }
  }
  
  # Encryption key hook - generate cryptographic keys
  encryptionKey {
    when = node.inputs.keyType == "rsa" || node.inputs.keyType == "ecdsa"
    
    module "asymmetric_key" {
      plugin = "native"
      build  = "./modules/encryption-key"
      inputs = {
        name     = "${environment.name}-${node.component}-${node.name}"
        key_type = node.inputs.keyType
        key_size = node.inputs.keySize
      }
    }
    
    outputs = {
      privateKey       = module.asymmetric_key.privateKey
      publicKey        = module.asymmetric_key.publicKey
      privateKeyBase64 = module.asymmetric_key.privateKeyBase64
      publicKeyBase64  = module.asymmetric_key.publicKeyBase64
    }
  }
  
  # Encryption key hook - symmetric keys
  encryptionKey {
    when = node.inputs.keyType == "symmetric"
    
    module "symmetric_key" {
      plugin = "native"
      build  = "./modules/encryption-key"
      inputs = {
        name     = "${environment.name}-${node.component}-${node.name}"
        key_type = "symmetric"
        key_size = node.inputs.keySize
      }
    }
    
    outputs = {
      key       = module.symmetric_key.key
      keyBase64 = module.symmetric_key.keyBase64
    }
  }
  
  # SMTP hook - local email testing with MailHog
  smtp {
    module "mailhog" {
      plugin = "native"
      build  = "./modules/local-smtp"
      inputs = {
        name    = "${environment.name}-${node.component}-${node.name}"
        network = variable.network_name
      }
    }
    
    outputs = {
      host     = module.mailhog.host
      port     = module.mailhog.port
      username = module.mailhog.username
      password = module.mailhog.password
    }
  }
  
  # Deployment hook - run Docker containers from built images
  # For components that have a build section (build.context/build.dockerfile)
  # The image comes from the completed dockerBuild dependency
  deployment {
    when = node.inputs.build != null
    
    module "container" {
      plugin = "native"
      build  = "./modules/docker-deployment"
      inputs = {
        name           = "${environment.name}-${node.component}-${node.name}"
        # Image is resolved by executor from build dependency outputs
        image          = node.inputs.image
        command        = node.inputs.command
        entrypoint     = node.inputs.entrypoint
        environment    = node.inputs.environment
        cpu            = node.inputs.cpu
        memory         = node.inputs.memory
        network        = variable.network_name
        liveness_probe = node.inputs.liveness_probe
        # Forward container stdout to OTel collector via fluentd driver
        log_driver = "fluentd"
        log_driver_options = {
          fluentd-address  = module.otel.fluentd_endpoint
          fluentd-async    = "true"
          tag              = "${environment.name}.${node.component}.${node.type}.${node.name}"
        }
      }
    }
    
    outputs = {
      id = module.container.container_id
    }
  }
  
  # Deployment hook - run pre-built Docker images
  # For components using existing images directly (no build section)
  deployment {
    when = node.inputs.image != null
    
    module "container" {
      plugin = "native"
      build  = "./modules/docker-deployment"
      inputs = {
        name          = "${environment.name}-${node.component}-${node.name}"
        image         = node.inputs.image
        command       = node.inputs.command
        entrypoint    = node.inputs.entrypoint
        environment   = node.inputs.environment
        cpu           = node.inputs.cpu
        memory        = node.inputs.memory
        network       = variable.network_name
        liveness_probe = node.inputs.liveness_probe
        # Forward container stdout to OTel collector via fluentd driver
        log_driver = "fluentd"
        log_driver_options = {
          fluentd-address  = module.otel.fluentd_endpoint
          fluentd-async    = "true"
          tag              = "${environment.name}.${node.component}.${node.type}.${node.name}"
        }
      }
    }
    
    outputs = {
      id = module.container.container_id
    }
  }
  
  # Deployment hook - run as local process for fast development
  # Handles deployments with runtime (VM workloads run as processes locally)
  # and deployments with neither image nor runtime (bare process execution)
  # Assumes system dependencies are installed; no Docker build needed
  deployment {
    when = node.inputs.image == null
    
    module "process" {
      plugin = "native"
      build  = "./modules/process-deployment"
      inputs = {
        name             = "${environment.name}-${node.component}-${node.name}"
        command          = node.inputs.command
        environment      = node.inputs.environment
        workingDirectory = node.inputs.workingDirectory
        cpu              = node.inputs.cpu
        memory           = node.inputs.memory
        liveness_probe   = node.inputs.liveness_probe
      }
    }
    
    outputs = {
      id = module.process.id
    }
  }
  
  # Function hook - run as local process for fast iteration
  function {
    module "process" {
      plugin = "native"
      build  = "./modules/process-function"
      inputs = {
        name        = "${environment.name}-${node.component}-${node.name}"
        context     = node.inputs.context
        command     = node.inputs.command
        environment = node.inputs.environment
        framework   = node.inputs.framework
      }
    }
    
    outputs = {
      id       = module.process.pid
      endpoint = module.process.endpoint
    }
  }
  
  # Service hook - expose container/process ports
  service {
    module "service" {
      plugin = "native"
      build  = "./modules/docker-service"
      inputs = {
        name        = node.name
        target      = node.inputs.target
        target_type = node.inputs.target_type
        port        = node.inputs.port
        protocol    = node.inputs.protocol
        host        = variable.host
      }
    }
    
    outputs = {
      host = module.service.host
      port = module.service.port
      url  = module.service.url
    }
  }
  
  # Route hook - for local dev, just expose the port directly
  route {
    module "route" {
      plugin = "native"
      build  = "./modules/local-route"
      inputs = {
        name        = "${environment.name}-${node.component}-${node.name}"
        type        = node.inputs.type
        rules       = node.inputs.rules
        internal    = node.inputs.internal
        host        = variable.host
      }
    }
    
    outputs = {
      url  = module.route.url
      host = module.route.host
      port = module.route.port
    }
  }
  
  # Docker build hook - build images locally
  dockerBuild {
    module "build" {
      plugin = "native"
      build  = "./modules/docker-build"
      inputs = {
        context    = node.inputs.context
        dockerfile = node.inputs.dockerfile
        target     = node.inputs.target
        args       = node.inputs.args
        tag        = "${environment.name}-${node.component}-${node.name}:local"
      }
    }
    
    outputs = {
      image = module.build.image
    }
  }
  
  # Cronjob hook - for local dev, run jobs manually or skip
  cronjob {
    module "cronjob" {
      plugin = "native"
      build  = "./modules/local-cronjob"
      inputs = {
        name        = "${environment.name}-${node.component}-${node.name}"
        schedule    = node.inputs.schedule
        image       = node.inputs.image
        command     = node.inputs.command
        environment = node.inputs.environment
        # In local dev, cronjobs are suspended by default
        suspended   = true
      }
    }
    
    outputs = {
      id = module.cronjob.id
    }
  }

  # Observability - local OpenTelemetry backend (Grafana + Loki + Tempo + Prometheus)
  # Spins up a grafana/otel-lgtm container that receives logs, traces, and metrics
  # via the standard OTLP endpoints. View everything in Grafana at the printed URL.
  # The engine merges datacenter attributes with component attributes and
  # auto-generated attributes (service.namespace, deployment.environment).
  #
  # Docker containers forward their stdout to the collector via the fluentd
  # logging driver so that `arcctl logs` can query all container output.
  observability {
    module "otel" {
      plugin = "native"
      build  = "./modules/docker-otel-backend"
      inputs = {
        name    = "${environment.name}-otel"
        network = variable.network_name
      }
    }

    outputs = {
      endpoint       = module.otel.otlp_http_endpoint
      protocol       = "http/protobuf"
      query_type     = "loki"
      query_endpoint = module.otel.loki_endpoint
      dashboard_url  = module.otel.grafana_url
      attributes = {
        cloud.provider = "local"
      }
    }
  }
}
