# Example: Shared database cluster for preview environments
# Uses a single database cluster shared across all environments for cost efficiency
# Ideal for preview/ephemeral environments where isolation is less critical

variable "cluster_name" {
  description = "Kubernetes cluster name"
  type        = string
}

variable "region" {
  description = "Cloud region"
  type        = string
  default     = "us-east-1"
}

variable "domain" {
  description = "Base domain for environments"
  type        = string
  default     = "preview.example.com"
}

# Shared database cluster connection info
variable "shared_postgres_host" {
  description = "Shared PostgreSQL cluster host"
  type        = string
}

variable "shared_postgres_port" {
  description = "Shared PostgreSQL cluster port"
  type        = string
  default     = "5432"
}

variable "shared_postgres_admin_user" {
  description = "Admin user for shared PostgreSQL"
  type        = string
  sensitive   = true
}

variable "shared_postgres_admin_password" {
  description = "Admin password for shared PostgreSQL"
  type        = string
  sensitive   = true
}

variable "shared_redis_host" {
  description = "Shared Redis cluster host"
  type        = string
}

variable "shared_redis_port" {
  description = "Shared Redis cluster port"
  type        = string
  default     = "6379"
}

environment {
  module "namespace" {
    build = "./modules/k8s-namespace"
    inputs = {
      name    = environment.name
      cluster = variable.cluster_name
    }
  }

  module "gateway" {
    when  = contains(environment.nodes.*.type, "ingress")
    build = "./modules/k8s-gateway"
    inputs = {
      name          = "${environment.name}-gateway"
      namespace     = environment.name
      gateway_class = "nginx"
    }
  }

  # Create a logical database in the shared cluster for this environment
  module "postgres_database" {
    when  = anytrue([for n in environment.nodes : element(split(":", n.inputs.type), 0) == "postgres" if n.type == "database"])
    build = "./modules/postgres-logical-db"
    inputs = {
      host           = variable.shared_postgres_host
      port           = variable.shared_postgres_port
      admin_user     = variable.shared_postgres_admin_user
      admin_password = variable.shared_postgres_admin_password
      database_name  = replace(environment.name, "-", "_")
    }
  }

  # Create a Redis key prefix for this environment (logical isolation)
  module "redis_namespace" {
    when  = anytrue([for n in environment.nodes : element(split(":", n.inputs.type), 0) == "redis" if n.type == "database"])
    build = "./modules/redis-namespace"
    inputs = {
      host       = variable.shared_redis_host
      port       = variable.shared_redis_port
      key_prefix = environment.name
    }
  }

  # Resource hooks
  database {
    module "shared_database" {
      build = "./modules/shared-database"
      inputs = {
        name        = node.name
        type        = element(split(":", node.inputs.type), 0)
        environment = environment.name
        # For postgres, use the shared cluster with environment-specific database
        postgres_host           = variable.shared_postgres_host
        postgres_port           = variable.shared_postgres_port
        postgres_database       = module.postgres_database.database_name
        postgres_admin_user     = variable.shared_postgres_admin_user
        postgres_admin_password = variable.shared_postgres_admin_password
        # For redis, use shared cluster with key prefix
        redis_host       = variable.shared_redis_host
        redis_port       = variable.shared_redis_port
        redis_key_prefix = environment.name
      }
    }

    outputs = {
      host     = module.shared_database.host
      port     = module.shared_database.port
      database = module.shared_database.database
      url      = module.shared_database.url
    }
  }

  databaseUser {
    # Create unique users per application within the shared database
    module "shared_db_user" {
      build = "./modules/shared-db-user"
      inputs = {
        database_type           = element(split(":", node.inputs.type), 0)
        database                = node.inputs.database
        username                = "${environment.name}_${node.inputs.username}"
        postgres_host           = variable.shared_postgres_host
        postgres_admin_user     = variable.shared_postgres_admin_user
        postgres_admin_password = variable.shared_postgres_admin_password
      }
    }

    outputs = {
      username = module.shared_db_user.username
      password = module.shared_db_user.password
      url      = module.shared_db_user.url
    }
  }

  bucket {
    module "s3_bucket" {
      build = "./modules/s3-bucket"
      inputs = {
        # Use a shared bucket with environment-specific prefix
        name       = "preview-shared-${node.name}"
        prefix     = "${environment.name}/"
        versioning = node.inputs.versioning
        public     = node.inputs.public
      }
    }

    outputs = {
      endpoint        = module.s3_bucket.endpoint
      bucket          = module.s3_bucket.bucket_name
      region          = variable.region
      accessKeyId     = module.s3_bucket.access_key_id
      secretAccessKey = module.s3_bucket.secret_access_key
    }
  }

  deployment {
    module "deployment" {
      build = "./modules/k8s-deployment"
      inputs = {
        name        = node.name
        namespace   = environment.name
        image       = node.inputs.image
        command     = node.inputs.command
        entrypoint  = node.inputs.entrypoint
        environment = node.inputs.environment
        # Use smaller resources for preview environments
        cpu             = "0.25"
        memory          = "256Mi"
        replicas        = 1
        liveness_probe  = node.inputs.liveness_probe
        readiness_probe = node.inputs.readiness_probe
      }
    }

    outputs = {
      id = module.deployment.deployment_id
    }
  }

  function {
    module "knative_service" {
      build = "./modules/knative-service"
      inputs = {
        name        = node.name
        namespace   = environment.name
        image       = node.inputs.image
        environment = node.inputs.environment
        # Smaller resources for preview
        memory        = "512Mi"
        timeout       = node.inputs.timeout
        scale_to_zero = true  # Cost saving for preview environments
      }
    }

    outputs = {
      id       = module.knative_service.service_id
      endpoint = module.knative_service.url
    }
  }

  service {
    module "service" {
      build = "./modules/k8s-service"
      inputs = {
        name        = node.name
        namespace   = environment.name
        target      = node.inputs.target
        target_type = node.inputs.target_type
        port        = node.inputs.port
      }
    }

    outputs = {
      host = module.service.cluster_ip
      port = module.service.port
      url  = "http://${module.service.cluster_ip}:${module.service.port}"
    }
  }

  ingress {
    module "httproute" {
      build = "./modules/k8s-httproute"
      inputs = merge(node.inputs, {
        namespace    = environment.name
        gateway_name = "${environment.name}-gateway"
      })
    }

    outputs = {
      url      = "https://${environment.name}.${variable.domain}"
      hosts    = ["${environment.name}.${variable.domain}"]
      protocol = "https"
      host     = "${environment.name}.${variable.domain}"
      port     = 443
    }
  }

  cronjob {
    # Disable cronjobs in preview environments to save resources
    module "cronjob_disabled" {
      build = "./modules/k8s-cronjob-disabled"
      inputs = {
        name      = node.name
        namespace = environment.name
        # Jobs are suspended by default in preview
        suspended = true
      }
    }

    outputs = {
      id = "disabled-${node.name}"
    }
  }

  dockerBuild {
    module "docker_build" {
      build = "./modules/docker-build"
      inputs = {
        context    = node.inputs.context
        dockerfile = node.inputs.dockerfile
        target     = node.inputs.target
        args       = node.inputs.args
      }
    }

    outputs = {
      image = module.docker_build.image
    }
  }
}
