# AWS EC2 (VMs) datacenter
# VM-based AWS template. ALL deployments run on EC2 instances.
# Container-based deployments install Docker on EC2 and run containers.
# Runtime-based deployments install the language runtime directly.
# Functions deploy as long-running processes on EC2 behind ALB.

variable "aws_region" {
  description = "AWS region"
  type        = string
  default     = "us-east-1"
}

variable "vpc_id" {
  description = "VPC ID for deployment"
  type        = string
}

variable "domain" {
  description = "Base domain for environments"
  type        = string
  default     = "app.example.com"
}

variable "hosted_zone_id" {
  description = "Route53 hosted zone ID"
  type        = string
}

variable "certificate_arn" {
  description = "ACM certificate ARN for TLS"
  type        = string
}

variable "ssh_key_pair" {
  description = "EC2 key pair name for SSH access"
  type        = string
}

variable "default_instance_type" {
  description = "Default EC2 instance type"
  type        = string
  default     = "t3.small"
}

variable "ses_identity_arn" {
  description = "AWS SES verified identity ARN for sending email"
  type        = string
  default     = ""
}

variable "ses_smtp_username" {
  description = "AWS SES SMTP username (IAM access key)"
  type        = string
  default     = ""
}

variable "ses_smtp_password" {
  description = "AWS SES SMTP password (IAM secret key)"
  type        = string
  sensitive   = true
  default     = ""
}

# Application Load Balancer (shared across environments)
module "alb" {
  build = "./modules/alb"
  inputs = {
    name            = "arcctl-alb"
    vpc_id          = variable.vpc_id
    certificate_arn = variable.certificate_arn
  }
}

environment {
  # ALB target group per environment
  module "target_group" {
    build = "./modules/alb-target-group"
    inputs = {
      name    = environment.name
      vpc_id  = variable.vpc_id
      alb_arn = module.alb.arn
    }
  }

  # Security group for environment
  module "security_group" {
    build = "./modules/security-group"
    inputs = {
      name   = "${environment.name}-sg"
      vpc_id = variable.vpc_id
    }
  }

  # CloudWatch log group
  module "log_group" {
    build = "./modules/cloudwatch-logs"
    inputs = {
      name           = "/ec2/${environment.name}"
      retention_days = 30
    }
  }

  # DNS records per environment
  module "dns_records" {
    build = "./modules/route53-records"
    inputs = {
      hosted_zone_id = variable.hosted_zone_id
      domain         = "${environment.name}.${variable.domain}"
      alb_dns_name   = module.alb.dns_name
      alb_zone_id    = module.alb.zone_id
    }
  }

  # Database hook - RDS
  database {
    module "rds_database" {
      build = "./modules/rds-database"
      inputs = {
        name              = "${environment.name}-${node.name}"
        type              = element(split(":", node.inputs.type), 0)
        version           = try(element(split(":", node.inputs.type), 1), null)
        region            = variable.aws_region
        vpc_id            = variable.vpc_id
        instance_class    = "db.t3.micro"
        allocated_storage = 20
        security_group_id = module.security_group.id
      }
    }

    outputs = {
      host     = module.rds_database.endpoint
      port     = module.rds_database.port
      database = module.rds_database.database_name
      url      = module.rds_database.connection_url
    }
  }

  # Task hook - one-time EC2 task via SSM Run Command
  task {
    module "ec2_task" {
      plugin = "opentofu"
      build  = "./modules/ec2-task"
      inputs = {
        name              = "${node.component}--${node.name}"
        region            = variable.aws_region
        vpc_id            = variable.vpc_id
        security_group_id = module.security_group.id
        key_pair          = variable.ssh_key_pair
        instance_type     = variable.default_instance_type
        image             = node.inputs.image
        command           = node.inputs.command
        environment       = node.inputs.environment
      }
    }

    outputs = {
      id     = module.ec2_task.instance_id
      status = module.ec2_task.status
    }
  }

  # Bucket hook - S3
  bucket {
    module "s3_bucket" {
      build = "./modules/s3-bucket"
      inputs = {
        name       = "${environment.name}-${node.name}"
        region     = variable.aws_region
        versioning = node.inputs.versioning
        public     = node.inputs.public
      }
    }

    outputs = {
      endpoint        = "https://s3.${variable.aws_region}.amazonaws.com"
      bucket          = module.s3_bucket.bucket_name
      region          = variable.aws_region
      accessKeyId     = module.s3_bucket.access_key_id
      secretAccessKey = module.s3_bucket.secret_access_key
    }
  }

  # Encryption key hook - asymmetric (RSA/ECDSA)
  encryptionKey {
    when = node.inputs.keyType == "rsa" || node.inputs.keyType == "ecdsa"

    module "asymmetric_key" {
      build = "./modules/secrets-manager-keypair"
      inputs = {
        name     = "${environment.name}/${node.component}/${node.name}"
        key_type = node.inputs.keyType
        key_size = node.inputs.keySize
        region   = variable.aws_region
      }
    }

    outputs = {
      privateKey       = module.asymmetric_key.private_key
      publicKey        = module.asymmetric_key.public_key
      privateKeyBase64 = module.asymmetric_key.private_key_base64
      publicKeyBase64  = module.asymmetric_key.public_key_base64
    }
  }

  # Encryption key hook - symmetric (KMS)
  encryptionKey {
    when = node.inputs.keyType == "symmetric"

    module "symmetric_key" {
      build = "./modules/kms-key"
      inputs = {
        name   = "${environment.name}-${node.component}-${node.name}"
        region = variable.aws_region
      }
    }

    outputs = {
      key       = module.symmetric_key.key_material
      keyBase64 = module.symmetric_key.key_material_base64
    }
  }

  # SMTP hook - AWS SES
  smtp {
    module "ses_smtp" {
      build = "./modules/ses-smtp"
      inputs = {
        region       = variable.aws_region
        identity_arn = variable.ses_identity_arn
      }
    }

    outputs = {
      host     = "email-smtp.${variable.aws_region}.amazonaws.com"
      port     = 587
      username = variable.ses_smtp_username
      password = variable.ses_smtp_password
    }
  }

  # Deployment hook - container-based (image present)
  # Provisions an EC2 instance, installs Docker, and runs the container
  deployment {
    when = node.inputs.image != null

    module "ec2_docker" {
      plugin = "opentofu"
      build  = "./modules/ec2-docker"
      inputs = merge(node.inputs, {
        name              = "${environment.name}-${node.component}-${node.name}"
        region            = variable.aws_region
        vpc_id            = variable.vpc_id
        security_group_id = module.security_group.id
        key_pair          = variable.ssh_key_pair
        instance_type     = variable.default_instance_type
        target_group_arn  = module.target_group.arn
        log_group         = module.log_group.name
      })
    }

    outputs = {
      id = module.ec2_docker.instance_id
    }
  }

  # Deployment hook - VM-based (runtime present, no image)
  # Provisions an EC2 instance with the specified language runtime installed
  deployment {
    when = node.inputs.runtime != null && node.inputs.image == null

    module "ec2_runtime" {
      plugin = "opentofu"
      build  = "./modules/ec2-runtime"
      inputs = merge(node.inputs, {
        name              = "${environment.name}-${node.component}-${node.name}"
        region            = variable.aws_region
        vpc_id            = variable.vpc_id
        security_group_id = module.security_group.id
        key_pair          = variable.ssh_key_pair
        instance_type     = variable.default_instance_type
        target_group_arn  = module.target_group.arn
        log_group         = module.log_group.name
      })
    }

    outputs = {
      id = module.ec2_runtime.instance_id
    }
  }

  # Function hook - deploy as long-running process on EC2 behind ALB
  # Functions are deployed as EC2 instances running the function handler
  # as a persistent HTTP server process, fronted by the ALB.
  function {
    module "ec2_function" {
      plugin = "opentofu"
      build  = "./modules/ec2-function"
      inputs = merge(node.inputs, {
        name              = "${environment.name}-${node.component}-${node.name}"
        region            = variable.aws_region
        vpc_id            = variable.vpc_id
        security_group_id = module.security_group.id
        key_pair          = variable.ssh_key_pair
        instance_type     = variable.default_instance_type
        target_group_arn  = module.target_group.arn
        log_group         = module.log_group.name
      })
    }

    outputs = {
      id       = module.ec2_function.instance_id
      endpoint = "http://${module.ec2_function.private_ip}:${module.ec2_function.port}"
    }
  }

  # Service hook - ALB target group routing
  service {
    module "alb_target" {
      build = "./modules/alb-target-registration"
      inputs = {
        name             = node.name
        target_group_arn = module.target_group.arn
        target           = node.inputs.target
        target_type      = node.inputs.target_type
        port             = node.inputs.port
      }
    }

    outputs = {
      host = module.alb_target.dns_name
      port = module.alb_target.port
      url  = "http://${module.alb_target.dns_name}:${module.alb_target.port}"
    }
  }

  # Ingress hook - ALB listener rules
  ingress {
    module "alb_listener_rule" {
      build = "./modules/alb-listener-rule"
      inputs = merge(node.inputs, {
        alb_arn          = module.alb.arn
        target_group_arn = module.target_group.arn
        domain           = "${environment.name}.${variable.domain}"
      })
    }

    outputs = {
      url      = "https://${environment.name}.${variable.domain}"
      hosts    = ["${environment.name}.${variable.domain}"]
      protocol = "https"
      host     = "${environment.name}.${variable.domain}"
      port     = 443
    }
  }

  # Cronjob hook - cron on a dedicated EC2 instance
  cronjob {
    module "ec2_cronjob" {
      plugin = "opentofu"
      build  = "./modules/ec2-cronjob"
      inputs = merge(node.inputs, {
        name              = "${environment.name}-${node.component}-${node.name}"
        region            = variable.aws_region
        vpc_id            = variable.vpc_id
        security_group_id = module.security_group.id
        key_pair          = variable.ssh_key_pair
        instance_type     = "t3.micro"
      })
    }

    outputs = {
      id = module.ec2_cronjob.instance_id
    }
  }

  # Database user hook
  databaseUser {
    module "rds_user" {
      build = "./modules/rds-user"
      inputs = {
        database = node.inputs.database
        username = node.inputs.username
      }
    }

    outputs = {
      username = module.rds_user.username
      password = module.rds_user.password
      url      = module.rds_user.connection_url
    }
  }

  # Secret hook - Secrets Manager
  secret {
    module "secrets_manager" {
      build = "./modules/secrets-manager"
      inputs = {
        name = "${environment.name}/${node.name}"
        data = node.inputs.data
      }
    }

    outputs = {
      id = module.secrets_manager.secret_arn
    }
  }

  # Docker build hook - ECR
  dockerBuild {
    module "ecr_build" {
      build = "./modules/ecr-build"
      inputs = {
        context    = node.inputs.context
        dockerfile = node.inputs.dockerfile
        target     = node.inputs.target
        args       = node.inputs.args
        region     = variable.aws_region
      }
    }

    outputs = {
      image = module.ecr_build.image_uri
    }
  }

  # Observability hook - CloudWatch agent on EC2
  # Installs the CloudWatch agent on each EC2 instance and runs an OTel
  # collector sidecar process that receives OTLP telemetry.
  observability {
    module "cloudwatch_agent" {
      build = "./modules/cloudwatch-agent"
      inputs = {
        name      = "${environment.name}-observability"
        region    = variable.aws_region
        log_group = module.log_group.name
      }
    }

    outputs = {
      endpoint       = module.cloudwatch_agent.otlp_endpoint
      protocol       = "http/protobuf"
      query_type     = "cloudwatch"
      query_endpoint = "https://logs.${variable.aws_region}.amazonaws.com"
      dashboard_url  = "https://${variable.aws_region}.console.aws.amazon.com/cloudwatch/home?region=${variable.aws_region}#dashboards"
      attributes = {
        "cloud.provider" = "aws"
        "cloud.region"   = variable.aws_region
        "cloud.platform" = "aws_ec2"
      }
    }
  }
}
