# Native module for running functions as local processes
# Ideal for fast local development iteration
plugin: native
type: process

inputs:
  name:
    type: string
    required: true
    description: Process identifier
  context:
    type: string
    required: true
    description: Working directory (source code location)
  command:
    type: list
    description: Command to run (defaults based on framework)
  environment:
    type: map
    default: {}
    description: Environment variables
  framework:
    type: string
    description: Framework hint (nextjs, react, node, python, etc.)
  port:
    type: number
    default: 0
    description: Port the application listens on (resolved from service/port resources). When > 0, used for readiness check. When 0, readiness check is skipped.

resources:
  process:
    type: process
    properties:
      name: "${inputs.name}"
      working_dir: "${inputs.context}"
      # Determine command based on framework if not specified
      command: "${coalesce(inputs.command, framework_command(inputs.framework))}"
      environment: "${inputs.environment}"
      resolve_to_localhost: true
      # Readiness check against the service port (skipped when port is 0).
      # Uses TCP instead of HTTP to avoid triggering on-demand page
      # compilation in dev servers (e.g. Next.js Turbopack). An HTTP
      # GET can cause heavy background compilation that, under file-
      # watcher pressure from multiple concurrent dev servers, may
      # lead to an unrecoverable compilation loop.
      readiness:
        type: tcp
        endpoint: "localhost:${inputs.port}"
        interval: 500ms
        timeout: 120s  # Dev servers can take a while to start
      # Graceful shutdown
      graceful_stop:
        signal: SIGTERM
        timeout: 10s

outputs:
  pid:
    value: "${resources.process.pid}"
    description: Process ID
  port:
    value: "${inputs.port}"
    description: Service port
  endpoint:
    value: "http://localhost:${inputs.port}"
    description: Local endpoint URL
