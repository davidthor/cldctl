# Native module for local routing via a shared nginx gateway.
#
# All routes in an environment share a single nginx gateway container.
# Each route writes its own nginx server block config file that matches
# on a subdomain (e.g., app.localhost, api.localhost). The gateway is
# created on-demand by the first route and cleaned up when the last
# route is destroyed.
#
# Modern browsers resolve *.localhost to 127.0.0.1 natively, so no
# /etc/hosts changes are needed.
plugin: native
type: docker

inputs:
  gateway_name:
    type: string
    required: true
    description: Shared gateway container name (environment-scoped, e.g. "myenv-gateway")
  config_dir:
    type: string
    required: true
    description: Host directory for nginx config (bind-mounted into the gateway)
  route_name:
    type: string
    required: true
    description: Unique route identifier for the config file name
  subdomain:
    type: string
    required: true
    description: Route subdomain (deterministic default generated by the engine)
  upstream_host:
    type: string
    default: "host.docker.internal"
    description: Upstream host reachable from inside the gateway container
  upstream_port:
    type: number
    required: true
    description: Port of the upstream service or function
  host:
    type: string
    default: "localhost"
    description: Host to bind to
  network:
    type: string
    required: true
    description: Docker network the gateway should join

resources:
  # Step 1: Ensure the shared gateway container exists.
  # Creates the config directory, writes the default catch-all server block,
  # and starts the container if it doesn't already exist.
  # Outputs the dynamically assigned host port.
  ensure_gateway:
    type: exec
    properties:
      command:
        - "sh"
        - "-c"
        - |
          mkdir -p "${inputs.config_dir}"
          if [ ! -f "${inputs.config_dir}/default.conf" ]; then
            cat > "${inputs.config_dir}/default.conf" << 'NGINXEOF'
          server {
              listen 80 default_server;
              server_name _;
              location / {
                  return 404 'No route configured for this subdomain';
              }
          }
          NGINXEOF
          fi
          if ! docker inspect "${inputs.gateway_name}" > /dev/null 2>&1; then
            docker run -d \
              --name "${inputs.gateway_name}" \
              --network "${inputs.network}" \
              --add-host "host.docker.internal:host-gateway" \
              -p 0:80 \
              -v "${inputs.config_dir}:/etc/nginx/conf.d" \
              --restart unless-stopped \
              nginx:alpine > /dev/null 2>&1
          elif [ "$(docker inspect --format '{{.State.Running}}' "${inputs.gateway_name}" 2>/dev/null)" != "true" ]; then
            docker start "${inputs.gateway_name}" > /dev/null 2>&1
          fi
          # Retry loop: handles race condition when multiple routes create the
          # gateway in parallel. The container may not be visible to docker
          # inspect immediately after a competing 'docker run -d' succeeds.
          for i in 1 2 3 4 5; do
            PORT=$(docker inspect --format '{{(index (index .NetworkSettings.Ports "80/tcp") 0).HostPort}}' "${inputs.gateway_name}" 2>/dev/null)
            if [ -n "$PORT" ]; then
              printf '%s' "$PORT"
              exit 0
            fi
            sleep 1
          done
          echo "ERROR: gateway container not ready after retries" >&2
          exit 1

  # Step 2: Write an nginx server block for this route.
  # Each route gets its own server block that matches on the subdomain.
  # Files are written directly to the config dir (not a subdirectory) so
  # nginx auto-includes them as separate server blocks at the http level.
  write_config:
    type: exec
    properties:
      command:
        - "sh"
        - "-c"
        - |
          cat > "${inputs.config_dir}/route-${inputs.route_name}.conf" << NGINXEOF
          server {
              listen 80;
              server_name ${inputs.subdomain}.${inputs.host};

              location / {
                  proxy_pass http://${inputs.upstream_host}:${inputs.upstream_port};
                  proxy_set_header Host \$http_host;
                  proxy_set_header X-Real-IP \$remote_addr;
                  proxy_set_header X-Forwarded-For \$proxy_add_x_forwarded_for;
                  proxy_set_header X-Forwarded-Proto \$scheme;
                  proxy_http_version 1.1;
                  proxy_set_header Upgrade \$http_upgrade;
                  proxy_set_header Connection "upgrade";
                  proxy_buffering off;
                  proxy_cache off;
                  # Dev servers can take 30+ seconds to compile on first request
                  proxy_read_timeout 300s;
                  proxy_connect_timeout 10s;
                  proxy_send_timeout 300s;
              }
          }
          NGINXEOF
      destroy:
        command:
          - "sh"
          - "-c"
          - |
            rm -f "${inputs.config_dir}/route-${inputs.route_name}.conf"
            if docker inspect "${inputs.gateway_name}" > /dev/null 2>&1; then
              docker exec "${inputs.gateway_name}" nginx -s reload 2>/dev/null || true
              remaining=$(ls "${inputs.config_dir}"/route-*.conf 2>/dev/null | wc -l | tr -d ' ')
              if [ "$remaining" = "0" ] || [ -z "$remaining" ]; then
                docker rm -f "${inputs.gateway_name}" 2>/dev/null || true
                rm -rf "${inputs.config_dir}"
              fi
            fi

  # Step 3: Reload nginx to pick up the new/updated config.
  reload_nginx:
    type: exec
    properties:
      command:
        - "sh"
        - "-c"
        - "sleep 1 && docker exec ${inputs.gateway_name} nginx -s reload 2>/dev/null || (sleep 2 && docker exec ${inputs.gateway_name} nginx -s reload)"

outputs:
  url:
    value: "http://${inputs.subdomain}.${inputs.host}:${resources.ensure_gateway.output}"
    description: Route URL (subdomain-based)
  port:
    value: "${resources.ensure_gateway.output}"
    description: Route port (shared gateway port)
  host:
    value: "${inputs.subdomain}.${inputs.host}"
    description: Route host (subdomain.host)
