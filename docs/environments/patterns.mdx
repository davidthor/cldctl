---
title: "Environment Patterns"
description: "Common patterns for development, staging, and production environments"
---

# Environment Patterns

Common patterns and examples for different environment types.

## Development Environment

Optimized for local development with minimal resources:

```yaml
name: dev
datacenter: local

locals:
  log_level: "debug"

components:
  my-app:
    path: ./                    # Local source
    variables:
      log_level: ${{ locals.log_level }}
    scaling:
      api:
        replicas: 1
        cpu: "0.1"
        memory: "256Mi"
```

### Key Characteristics

- Uses local source paths for rapid iteration
- Minimal resource allocation
- Debug logging enabled
- Single replica for simplicity

## Preview/PR Environment

Short-lived environments for pull request review:

```yaml
name: preview-123
datacenter: aws-staging

locals:
  pr_number: "123"
  log_level: "debug"

components:
  my-app:
    image: ghcr.io/myorg/my-app:pr-123
    variables:
      log_level: ${{ locals.log_level }}
    scaling:
      api:
        replicas: 1
    routes:
      main:
        hostnames:
          - subdomain: preview-123
        tls:
          enabled: true
```

### Key Characteristics

- Dynamic naming based on PR number
- Minimal resources (cost optimization)
- Automatic cleanup when PR closes
- Unique subdomain per PR

### CI/CD Integration

```yaml
# GitHub Actions example
- name: Deploy Preview
  run: |
    cldctl env create preview-${{ github.event.number }} \
      --datacenter aws-staging --if-not-exists
    
    cldctl deploy ghcr.io/myorg/my-app:pr-${{ github.event.number }} \
      -e preview-${{ github.event.number }}

- name: Cleanup Preview
  if: github.event.action == 'closed'
  run: |
    cldctl env destroy preview-${{ github.event.number }} --auto-approve
```

## Staging Environment

Production-like environment for testing:

```yaml
name: staging
datacenter: aws-production

locals:
  log_level: "debug"
  stripe_key: "sk_test_abc123"
  base_domain: "staging.example.com"

components:
  auth-service:
    image: ghcr.io/myorg/auth:v2.1.0
    variables:
      jwt_secret: ${{ locals.jwt_secret }}
      log_level: ${{ locals.log_level }}
    scaling:
      api:
        replicas: 2
        cpu: "0.5"
        memory: "512Mi"
    routes:
      public:
        hostnames:
          - subdomain: auth
        tls:
          enabled: true

  web-app:
    image: ghcr.io/myorg/web-app:v1.5.0
    variables:
      stripe_key: ${{ locals.stripe_key }}
      log_level: ${{ locals.log_level }}
    scaling:
      api:
        replicas: 2
    functions:
      frontend:
        memory: "1024Mi"
    environment:
      frontend:
        NEXT_PUBLIC_API_URL: https://api.${{ locals.base_domain }}
    routes:
      main:
        hostnames:
          - subdomain: www
          - subdomain: api
        tls:
          enabled: true

  worker:
    image: ghcr.io/myorg/worker:v1.2.0
    variables:
      log_level: "info"
    scaling:
      processor:
        replicas: 2
```

### Key Characteristics

- Uses same datacenter as production
- Moderate resource allocation
- Debug logging for troubleshooting
- Test API keys and credentials
- TLS enabled

## Production Environment

High-availability production deployment:

```yaml
name: production
datacenter: aws-production

locals:
  log_level: "warn"
  stripe_key: "sk_live_xyz789"
  sentry_dsn: "https://production-sentry..."

components:
  auth-service:
    image: ghcr.io/myorg/auth:v2.1.0
    variables:
      jwt_secret: ${{ locals.jwt_secret }}
      log_level: ${{ locals.log_level }}
      sentry_dsn: ${{ locals.sentry_dsn }}
    scaling:
      api:
        replicas: 5
        cpu: "1"
        memory: "1Gi"
    routes:
      public:
        hostnames:
          - host: auth.example.com
        tls:
          enabled: true
          secretName: production-auth-tls

  web-app:
    image: ghcr.io/myorg/web-app:v1.5.0
    variables:
      stripe_key: ${{ locals.stripe_key }}
      log_level: ${{ locals.log_level }}
      sentry_dsn: ${{ locals.sentry_dsn }}
    scaling:
      api:
        replicas: 10
        cpu: "2"
        memory: "4Gi"
    functions:
      frontend:
        regions: ["us-east-1", "us-west-2", "eu-west-1"]
        memory: "2048Mi"
        timeout: 30
    routes:
      main:
        hostnames:
          - host: app.example.com
          - host: www.example.com
        tls:
          enabled: true
          secretName: production-app-tls

  worker:
    image: ghcr.io/myorg/worker:v1.2.0
    variables:
      log_level: "warn"
      sentry_dsn: ${{ locals.sentry_dsn }}
    scaling:
      processor:
        replicas: 20
        cpu: "1"
        memory: "2Gi"
```

### Key Characteristics

- High replica counts for availability
- Generous resource allocation
- Production API keys
- Warn-level logging (reduced noise)
- Multi-region functions
- Custom TLS certificates
- Explicit production hostnames

## Multi-Tenant Environment

Shared infrastructure with tenant isolation:

```yaml
name: tenant-acme
datacenter: aws-multitenant

locals:
  tenant_id: "acme"
  tenant_domain: "acme.example.com"

components:
  web-app:
    image: ghcr.io/myorg/web-app:v1.5.0
    variables:
      tenant_id: ${{ locals.tenant_id }}
    scaling:
      api:
        replicas: 3
    routes:
      main:
        hostnames:
          - host: ${{ locals.tenant_domain }}
        tls:
          enabled: true
```

## Canary Deployment

Gradual rollout of new versions:

```yaml
name: production
datacenter: aws-production

components:
  # Stable version (90% traffic)
  web-app-stable:
    image: ghcr.io/myorg/web-app:v1.5.0
    scaling:
      api:
        replicas: 9

  # Canary version (10% traffic)  
  web-app-canary:
    image: ghcr.io/myorg/web-app:v1.6.0-rc1
    scaling:
      api:
        replicas: 1
```

Traffic splitting is configured at the route level in the component definition.

## Environment Promotion

Pattern for promoting through environments:

```bash
# 1. Deploy to staging
cldctl deploy ghcr.io/myorg/web-app:v1.6.0 -e staging

# 2. Test in staging...

# 3. Promote to production (same artifact)
cldctl deploy ghcr.io/myorg/web-app:v1.6.0 -e production
```

Using the same artifact ensures consistency across environments.

## Secrets with Environment Variables

Use the `variables` block to keep secrets out of version control:

```yaml
# environment.yml (checked in)
name: staging

variables:
  stripe_key:
    description: "Stripe secret key"
    required: true
    sensitive: true
  sentry_dsn:
    description: "Sentry DSN"
    required: true
  log_level:
    description: "Log level"
    default: "info"

locals:
  base_domain: staging.example.com

components:
  web-app:
    image: ghcr.io/myorg/web-app:v1.5.0
    variables:
      stripe_key: ${{ variables.stripe_key }}
      sentry_dsn: ${{ variables.sentry_dsn }}
      log_level: ${{ variables.log_level }}
```

```bash
# .env.local (gitignored)
STRIPE_KEY=sk_test_abc123
SENTRY_DSN=https://abc@sentry.io/123
```

The environment file is safe to check in. Secrets resolve from `.env.local` locally or from OS environment variables in CI. See [Environment Variables](/environments/variables) for full details.
