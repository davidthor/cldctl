---
title: "deploy component"
description: "Deploy a component to an environment"
---

# cldctl deploy component

Deploy a component to an environment.

<Note>
Use `cldctl deploy comp` as shorthand for `cldctl deploy component`.
</Note>

## Synopsis

```bash
cldctl deploy component <image> -e <environment> [options]
```

## Arguments

| Argument | Description |
|----------|-------------|
| `<image>` | OCI image reference for the component artifact (e.g., `ghcr.io/myorg/myapp:v1.0.0`). If not in the local cache, the image is pulled automatically. |

## Options

| Option | Description |
|--------|-------------|
| `-e, --environment <name>` | Target environment (required) |
| `-d, --datacenter <name>` | Target datacenter (resolved from flag, `CLDCTL_DATACENTER` env var, or CLI config default) |
| `--var <key=value>` | Set a component variable (repeatable) |
| `--var-file <path>` | Load variables from file |
| `--auto-approve` | Skip confirmation prompt |
| `--import-file <path>` | Import existing cloud resources from a mapping file during deploy |
| `--target <resource>` | Target specific resource (repeatable) |
| `--backend <type>` | State backend type |
| `--backend-config <key=value>` | Backend configuration |

## Image Resolution

The image argument must be an OCI image reference. Components must be built into an image
first using `cldctl build component` before they can be deployed.

If the image is already in the local cache (from a previous build or pull), it is used
directly. Otherwise, cldctl automatically pulls it from the remote registry and caches
it locally before proceeding with deployment.

```bash
# Build first, then deploy
cldctl build component ./my-app -t ghcr.io/myorg/web-app:v1.5.0
cldctl deploy component ghcr.io/myorg/web-app:v1.5.0 -e staging

# Or pull and deploy in one step (auto-pull from registry)
cldctl deploy component ghcr.io/myorg/web-app:v1.5.0 -e staging
```

## Interactive Variable Prompts

When running interactively (not in CI), cldctl will prompt you to enter values for any required variables that were not provided via `--var` or `--var-file`:

```
$ cldctl deploy component myapp:latest -e staging

The following variables need values:

  api_key (Your API key) [required]: ********
  log_level (Logging verbosity): debug

Component:   my-app
Environment: staging
...
```

Sensitive variables are masked during input. In CI environments, missing required variables will cause the command to fail with an error message listing the missing variables.

## Examples

```bash
# Deploy from OCI image
cldctl deploy component ghcr.io/myorg/web-app:v1.5.0 -e staging

# Using alias
cldctl deploy comp ghcr.io/myorg/web-app:v1.5.0 -e staging

# Deploy with variables
cldctl deploy component ghcr.io/myorg/web-app:v1.5.0 -e staging \
  --var log_level=debug \
  --var-file ./vars/staging.dcvars

# Deploy with auto-approval (CI/CD)
cldctl deploy component ghcr.io/myorg/web-app:v1.5.0 -e staging \
  --auto-approve

# Deploy with S3 backend
cldctl deploy component ghcr.io/myorg/web-app:v1.5.0 -e staging \
  --backend s3 \
  --backend-config bucket=my-cldctl-state

# Target specific resource
cldctl deploy component ghcr.io/myorg/web-app:v1.5.0 -e staging \
  --target deployment.api
```

## Execution Plan Output

```
$ cldctl deploy component ghcr.io/myorg/web-app:v1.5.0 -e staging

Component:   web-app
Environment: staging
Image:       ghcr.io/myorg/web-app:v1.5.0

Execution Plan:

  database "main" (postgres:^15)
    + create: Database "staging-web-app-main"
    
  deployment "api"
    + create: Deployment "staging-web-app-api"
    
  service "api"
    + create: Service "staging-web-app-api"
    
  route "main"
    + create: Route "staging-web-app-main"

Plan: 4 to create, 0 to update, 0 to destroy

Proceed with deployment? [Y/n]:
```

## Automatic Dependency Deployment

When a component declares dependencies on other components (via the `dependencies` field in `cloud.component.yml`), cldctl will automatically deploy any dependencies that are not already present in the target environment. Dependencies are resolved transitively -- if dependency A depends on dependency B, both will be deployed.

```
$ cldctl deploy component myapp:latest -e staging

Dependencies to deploy:
  shared-db (ghcr.io/myorg/shared-db:v1)
  auth-service (ghcr.io/myorg/auth:v2)

Component:   my-app
Environment: staging
...
```

If a dependency has required variables without defaults, cldctl will prompt you for values in interactive mode:

```
Dependency "shared-db" requires the following variables:

  admin_password (Database admin password) [required]: ********
```

In CI/CD or `--auto-approve` mode, missing dependency variables will cause the command to fail:

```
Error: cannot auto-deploy dependency "shared-db": missing required variables: admin_password
Provide values with --var or deploy the dependency manually first
```

Dependencies that are already deployed in the environment are skipped -- they are not updated automatically. To update a dependency, deploy it explicitly.

<Card title="Automatic Dependency Deployment Guide" icon="diagram-project" href="/guides/components/dependency-deployment">
  In-depth guide on recursive dependency deployment, ephemeral environments, pass-through components, and CI/CD patterns
</Card>

## CI/CD Usage

In CI/CD pipelines, use `--auto-approve` and provide all required variables via `--var` or `--var-file`:

```bash
cldctl deploy component ghcr.io/myorg/web-app:v1.5.0 -e staging \
  --var api_key=$API_KEY \
  --var database_url=$DATABASE_URL \
  --auto-approve
```

If required variables are missing in CI, the command will fail with an error:

```
Error: missing required variables: api_key, database_url
Use --var or --var-file to provide values, or run interactively
```

## See Also

- [`cldctl destroy component`](/cli/destroy/component) - Destroy a deployed component
- [`cldctl list component`](/cli/list/component) - List deployed components
- [`cldctl get component`](/cli/get/component) - Get component details
