---
title: "Deployment Hook"
description: "Create container, VM, or process deployments for components"
---

# Deployment Hook

The deployment hook creates long-running workloads when components declare deployments. It receives the deployment specification and creates the appropriate infrastructure. Datacenters can use `when` conditions to route deployments to different backends based on the presence of `image`, `runtime`, or neither.

## Basic Usage

```hcl
deployment {
  module "deployment" {
    build = "./modules/k8s-deployment"
    inputs = merge(node.inputs, {
      name       = "${environment.name}-${node.component}-${node.name}"
      namespace  = module.namespace.id
      kubeconfig = module.k8s.kubeconfig
    })
  }

  outputs = {
    id = module.deployment.deployment_id
  }
}
```

## Inputs

The following inputs are available via `node.inputs`:

| Field | Type | Description |
|-------|------|-------------|
| `name` | string | Deployment name |
| `image` | string | Container image (optional) |
| `runtime` | object | Runtime specification for VM-based deployments (optional) |
| `runtime.language` | string | Language and version (e.g., `node:20`, `python:^3.12`) |
| `runtime.os` | string | Target OS (`linux`, `windows`) |
| `runtime.arch` | string | Target architecture (`amd64`, `arm64`) |
| `runtime.packages` | string[] | System-level dependencies |
| `runtime.setup` | string[] | Provisioning commands |
| `command` | string[] | Container/process command |
| `entrypoint` | string[] | Container entrypoint |
| `environment` | map | Environment variables |
| `workingDirectory` | string | Working directory for process-based execution |
| `cpu` | string | CPU allocation |
| `memory` | string | Memory allocation |
| `replicas` | number | Replica count |
| `liveness_probe` | object | Liveness configuration |
| `readiness_probe` | object | Readiness configuration |

## Three-Way Routing Model

Datacenters can use `when` conditions to route deployments to different backends:

- **`image` present** -- container-based (Docker, Kubernetes, ECS)
- **`runtime` present, no `image`** -- VM-based (EC2, Droplets, GCE)
- **Neither** -- process-based local execution

```hcl
# Container-based deployments
deployment {
  when = node.inputs.image != null

  module "container" {
    build = "./modules/k8s-deployment"
    inputs = merge(node.inputs, {
      namespace  = environment.name
      kubeconfig = module.k8s.kubeconfig
    })
  }

  outputs = {
    id = module.container.deployment_id
  }
}

# VM-based deployments (runtime without image)
deployment {
  when = node.inputs.runtime != null && node.inputs.image == null

  module "vm" {
    plugin = "opentofu"
    build  = "./modules/ec2-vm"
    inputs = merge(node.inputs, {
      name           = "${environment.name}-${node.component}-${node.name}"
      subnet_id      = module.network.subnet_id
      security_group = module.sg.id
      key_pair       = variable.ssh_key_pair
    })
  }

  outputs = {
    id = module.vm.instance_id
  }
}

# Process-based deployments (no image, no runtime)
deployment {
  when = node.inputs.image == null && node.inputs.runtime == null

  module "process" {
    plugin = "native"
    build  = "./modules/process-deployment"
    inputs = merge(node.inputs, {
      name = "${environment.name}-${node.component}-${node.name}"
    })
  }

  outputs = {
    id = module.process.id
  }
}
```

## Required Outputs

| Field | Type | Description |
|-------|------|-------------|
| `id` | string | Unique deployment identifier |

## Example Pulumi Module

```typescript
// modules/k8s-deployment/index.ts
import * as pulumi from "@pulumi/pulumi";
import * as k8s from "@pulumi/kubernetes";

const config = new pulumi.Config();
const name = config.require("name");
const namespace = config.require("namespace");
const image = config.require("image");
const replicas = config.getNumber("replicas") || 1;
const cpu = config.get("cpu") || "100m";
const memory = config.get("memory") || "128Mi";
const environment = config.getObject<Record<string, string>>("environment") || {};

const deployment = new k8s.apps.v1.Deployment("deployment", {
  metadata: {
    name: name,
    namespace: namespace,
  },
  spec: {
    replicas: replicas,
    selector: {
      matchLabels: { app: name },
    },
    template: {
      metadata: {
        labels: { app: name },
      },
      spec: {
        containers: [{
          name: "main",
          image: image,
          resources: {
            requests: { cpu, memory },
            limits: { cpu, memory },
          },
          env: Object.entries(environment).map(([name, value]) => ({
            name,
            value,
          })),
        }],
      },
    },
  },
});

export const deployment_id = deployment.metadata.name;
```

## Example OpenTofu Module

```hcl
# modules/k8s-deployment/main.tf
variable "name" {
  type = string
}

variable "namespace" {
  type = string
}

variable "image" {
  type = string
}

variable "replicas" {
  type    = number
  default = 1
}

variable "cpu" {
  type    = string
  default = "100m"
}

variable "memory" {
  type    = string
  default = "128Mi"
}

variable "environment" {
  type    = map(string)
  default = {}
}

resource "kubernetes_deployment" "deployment" {
  metadata {
    name      = var.name
    namespace = var.namespace
  }

  spec {
    replicas = var.replicas

    selector {
      match_labels = {
        app = var.name
      }
    }

    template {
      metadata {
        labels = {
          app = var.name
        }
      }

      spec {
        container {
          name  = "main"
          image = var.image

          resources {
            requests = {
              cpu    = var.cpu
              memory = var.memory
            }
            limits = {
              cpu    = var.cpu
              memory = var.memory
            }
          }

          dynamic "env" {
            for_each = var.environment
            content {
              name  = env.key
              value = env.value
            }
          }
        }
      }
    }
  }
}

output "deployment_id" {
  value = kubernetes_deployment.deployment.metadata[0].name
}
```

## Health Checks

Handle health check configuration:

```hcl
deployment {
  module "deployment" {
    build = "./modules/k8s-deployment"
    inputs = {
      name           = "${environment.name}-${node.component}-${node.name}"
      namespace      = module.namespace.id
      image          = node.inputs.image
      replicas       = node.inputs.replicas
      cpu            = node.inputs.cpu
      memory         = node.inputs.memory
      environment    = node.inputs.environment
      liveness_probe = node.inputs.liveness_probe
      readiness_probe = node.inputs.readiness_probe
    }
  }

  outputs = {
    id = module.deployment.deployment_id
  }
}
```

## AWS ECS Example

For ECS-based datacenters (container deployments):

```hcl
deployment {
  when = node.inputs.image != null

  module "ecs_service" {
    build = "./modules/ecs-service"
    inputs = {
      name        = "${environment.name}-${node.component}-${node.name}"
      cluster_arn = module.ecs_cluster.cluster_arn
      image       = node.inputs.image
      cpu         = node.inputs.cpu
      memory      = node.inputs.memory
      replicas    = node.inputs.replicas
      environment = node.inputs.environment
    }
  }

  outputs = {
    id = module.ecs_service.service_arn
  }
}
```

## AWS EC2 VM Example

For VM-based deployments using the `runtime` property:

```hcl
deployment {
  when = node.inputs.runtime != null && node.inputs.image == null

  module "ec2_vm" {
    plugin = "opentofu"
    build  = "./modules/ec2-vm"
    inputs = merge(node.inputs, {
      name           = "${environment.name}-${node.component}-${node.name}"
      subnet_id      = module.network.subnet_id
      security_group = module.sg.id
      key_pair       = variable.ssh_key_pair
    })
  }

  outputs = {
    id = module.ec2_vm.instance_id
  }
}
```

The Terraform module receives the `runtime` object and uses it to:
1. Select an appropriate base AMI
2. Install the language runtime (e.g., Node.js, Python, Go)
3. Install system packages from `runtime.packages`
4. Run setup commands from `runtime.setup`
5. Create a systemd service with the deployment command

## DigitalOcean Droplet Example

```hcl
deployment {
  when = node.inputs.runtime != null && node.inputs.image == null

  module "droplet" {
    plugin = "opentofu"
    build  = "./modules/do-droplet"
    inputs = merge(node.inputs, {
      name                = "${environment.name}-${node.component}-${node.name}"
      region              = variable.region
      do_token            = variable.do_token
      ssh_key_fingerprint = variable.ssh_key_fingerprint
    })
  }

  outputs = {
    id = module.droplet.droplet_id
  }
}
```
