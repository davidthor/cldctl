---
title: "Route Hook"
description: "Set up external traffic routing for components"
---

# Route Hook

The route hook sets up external traffic routing when components declare routes. It handles DNS, TLS certificates, and load balancer configuration.

## Basic Usage

```hcl
route {
  module "route" {
    build = "./modules/route-rule"
    inputs = merge(node.inputs, {
      name      = "${node.component}--${node.name}"
      namespace = module.namespace.id
      dns_zone  = variable.domain
    })
  }

  module "dns" {
    build = "./modules/dns-record"
    inputs = {
      domain    = variable.domain
      subdomain = "${environment.name}-${node.component}"
      value     = module.route.load_balancer_ip
    }
  }

  outputs = {
    url  = module.route.url
    host = module.route.host
    port = module.route.port
  }
}
```

## Inputs

The following inputs are available via `node.inputs`:

| Field | Type | Description |
|-------|------|-------------|
| `name` | string | Route name |
| `type` | string | Route type (http, grpc) |
| `internal` | boolean | VPC-only access |
| `rules` | array | Routing rules |
| `service` | string | Target service (shorthand) |
| `port` | number | Target port (shorthand) |
| `subdomain` | string | Route subdomain. Set from environment config or generated deterministically (e.g., `salty-aardvark`). Always present. |
| `path_prefix` | string | Route path prefix. Set from environment config or defaults to `"/"`. Always present. |
| `target` | string | Name of the target service or function |
| `targetType` | string | Type of target: `"service"` or `"function"` |
| `upstream_port` | number | Resolved port of the upstream service/function (auto-populated by the executor) |

<Info>
`upstream_port` is automatically resolved by the executor based on the route's target.
For **service** targets, it uses the service's declared port. For **function** targets, it resolves the port from the function's associated service or port allocation.
</Info>

## Required Outputs

| Field | Type | Description |
|-------|------|-------------|
| `url` | string | Primary public URL |
| `host` | string | Assigned hostname |
| `port` | number | Assigned port |

## Kubernetes Gateway API Example

```hcl
route {
  module "httproute" {
    build = "./modules/k8s-httproute"
    inputs = {
      name         = "${node.component}--${node.name}"
      namespace    = module.namespace.id
      gateway_name = "${environment.name}-gateway"
      host         = "${environment.name}.${variable.domain}"
      service      = node.inputs.service
      port         = node.inputs.port
      rules        = node.inputs.rules
    }
  }

  module "certificate" {
    build = "./modules/cert-manager-cert"
    inputs = {
      name      = "${node.component}--${node.name}"
      namespace = module.namespace.id
      host      = "${environment.name}.${variable.domain}"
    }
  }

  outputs = {
    url  = "https://${environment.name}.${variable.domain}"
    host = "${environment.name}.${variable.domain}"
    port = 443
  }
}
```

### Pulumi Module

```typescript
// modules/k8s-httproute/index.ts
import * as pulumi from "@pulumi/pulumi";
import * as k8s from "@pulumi/kubernetes";

const config = new pulumi.Config();
const name = config.require("name");
const namespace = config.require("namespace");
const gatewayName = config.require("gateway_name");
const host = config.require("host");
const service = config.require("service");
const port = config.requireNumber("port");

const httproute = new k8s.apiextensions.CustomResource("httproute", {
  apiVersion: "gateway.networking.k8s.io/v1",
  kind: "HTTPRoute",
  metadata: {
    name: name,
    namespace: namespace,
  },
  spec: {
    parentRefs: [{
      name: gatewayName,
      namespace: namespace,
    }],
    hostnames: [host],
    rules: [{
      backendRefs: [{
        name: service,
        port: port,
      }],
    }],
  },
});

export const url = `https://${host}`;
export const host_out = host;
```

## AWS ALB Example

```hcl
route {
  module "alb" {
    build = "./modules/alb-listener-rule"
    inputs = {
      name        = "${environment.name}-${node.component}-${node.name}"
      vpc_id      = module.vpc.vpc_id
      subnets     = module.vpc.public_subnets
      target_port = node.inputs.port
      rules       = node.inputs.rules
    }
  }

  module "route53" {
    build = "./modules/route53-record"
    inputs = {
      zone_id = variable.route53_zone_id
      name    = "${environment.name}.${variable.domain}"
      type    = "A"
      alias = {
        name    = module.alb.dns_name
        zone_id = module.alb.zone_id
      }
    }
  }

  outputs = {
    url  = "https://${environment.name}.${variable.domain}"
    host = "${environment.name}.${variable.domain}"
    port = 443
  }
}
```

## Internal Routes

Handle internal (VPC-only) routes:

```hcl
route {
  when = node.inputs.internal == false

  module "public_route" {
    build = "./modules/public-route"
    inputs = {
      name = "${node.component}--${node.name}"
      host = "${environment.name}.${variable.domain}"
    }
  }

  outputs = {
    url  = "https://${environment.name}.${variable.domain}"
    host = "${environment.name}.${variable.domain}"
    port = 443
  }
}

route {
  when = node.inputs.internal == true

  module "internal_route" {
    build = "./modules/internal-route"
    inputs = {
      name = "${node.component}--${node.name}"
      host = "${environment.name}.internal.${variable.domain}"
    }
  }

  outputs = {
    url  = "https://${environment.name}.internal.${variable.domain}"
    host = "${environment.name}.internal.${variable.domain}"
    port = 443
  }
}
```

## Local Development â€” Shared Nginx Gateway

For local development, you can use a single nginx container as a shared gateway for all routes in an environment. Each route writes a location-block config file and reloads nginx, rather than creating a separate container per route.

Routes are accessible at `http://localhost:<gateway-port>/<route-name>/`, with the path prefix stripped before forwarding to the upstream service.

```hcl
route {
  module "route" {
    plugin = "native"
    build  = "./modules/local-route"
    inputs = {
      gateway_name  = "${environment.name}-gateway"
      config_dir    = "/tmp/cldctl-${environment.name}-gateway"
      route_name    = "${node.component}--${node.name}"
      path_prefix   = node.name
      upstream_host = "host.docker.internal"
      upstream_port = node.inputs.upstream_port
      host          = variable.host
      network       = variable.network_name
    }
  }

  outputs = {
    url  = module.route.url
    host = module.route.host
    port = module.route.port
  }
}
```

The `upstream_port` input is resolved automatically by the executor from the target service or function's declared port. Inside the nginx container, `host.docker.internal` reaches services and functions running on the host machine.

## Traffic Splitting

Handle weighted routing rules:

```hcl
route {
  module "route" {
    build = "./modules/k8s-httproute-canary"
    inputs = {
      name      = "${node.component}--${node.name}"
      namespace = module.namespace.id
      host      = "${environment.name}.${variable.domain}"
      rules     = node.inputs.rules  # Contains backendRefs with weights
    }
  }

  outputs = {
    url  = "https://${environment.name}.${variable.domain}"
    host = "${environment.name}.${variable.domain}"
    port = 443
  }
}
```
