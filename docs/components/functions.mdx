---
title: "Functions"
description: "Define serverless functions in cldctl components"
---

# Functions

Define serverless functions for auto-scaling workloads. Functions scale to zero when idle and automatically scale up based on demand.

## Basic Usage

Functions support two modes: **source-based** (runs from source code) and **container-based** (runs from Docker image).

### Source-Based Functions (Recommended)

```yaml
functions:
  web:
    src:
      path: ./web
      # Most fields are optional - inferred from project files
    environment:
      DATABASE_URL: ${{ databases.main.url }}
```

### Container-Based Functions

```yaml
functions:
  api:
    container:
      build:
        context: ./api
        dockerfile: Dockerfile
    port: 8080
```

## Source-Based Properties

| Property | Type | Description |
|----------|------|-------------|
| `src.path` | string | **Required.** Path to source code directory |
| `src.language` | string | Language (auto-detected): `javascript`, `typescript`, `python`, `go` |
| `src.runtime` | string | Runtime for serverless platforms: `nodejs20.x`, `python3.11` |
| `src.framework` | string | Framework hint: `nextjs`, `nuxt`, `fastapi`, `gin` |
| `src.install` | string | Install command (auto-detected from lockfiles) |
| `src.dev` | string | Development command (auto-detected from package.json/Makefile) |
| `src.build` | string | Production build command |
| `src.start` | string | Production start command |
| `src.handler` | string | Lambda-style handler: `index.handler` |
| `src.entry` | string | Entry point file |

## Container-Based Properties

| Property | Type | Description |
|----------|------|-------------|
| `container.build` | object | Build from Dockerfile |
| `container.build.context` | string | Build context directory |
| `container.build.dockerfile` | string | Dockerfile path (default: `Dockerfile`) |
| `container.image` | string | Pre-built container image (mutually exclusive with build) |

## Common Properties

| Property | Type | Description |
|----------|------|-------------|
| `port` | number or expression | Port the function listens on. Supports static values (`3000`) or expressions (`${{ ports.web.port }}`). Used for readiness checks and route upstream discovery. |
| `environment` | map | Environment variables |
| `memory` | string | Memory allocation per invocation |
| `timeout` | number | Maximum execution time in seconds |
| `cpu` | string | CPU allocation |

## Automatic Inference

For source-based functions, cldctl automatically detects:

- **Language**: From `package.json`, `go.mod`, `pyproject.toml`, `requirements.txt`
- **Framework**: From dependencies (Next.js, FastAPI, Gin, etc.)
- **Package Manager**: From lockfiles (`pnpm-lock.yaml`, `yarn.lock`, `poetry.lock`)
- **Commands**: From `package.json` scripts or `Makefile` targets

### Example with Minimal Config

```yaml
functions:
  web:
    src:
      path: ./apps/web
    # Everything else is inferred:
    # - Language: typescript (from tsconfig.json)
    # - Framework: nextjs (from package.json dependencies)
    # - Install: pnpm install (from pnpm-lock.yaml)
    # - Dev: pnpm run dev (from package.json scripts)
    # - Port: 3000 (framework default)
```

## Framework Support

Specify a framework hint for specialized platform support:

```yaml
functions:
  web:
    src:
      path: ./web
      framework: nextjs
    
  docs:
    src:
      path: ./docs
      framework: nuxt
```

Supported frameworks with auto-detection:

| Framework | Language | Default Port | Detection |
|-----------|----------|--------------|-----------|
| `nextjs` | TypeScript/JavaScript | 3000 | `next` dependency |
| `nuxt` | TypeScript/JavaScript | 3000 | `nuxt` dependency |
| `remix` | TypeScript/JavaScript | 3000 | `@remix-run/*` dependencies |
| `express` | JavaScript | 3000 | `express` dependency |
| `hono` | TypeScript | 3000 | `hono` dependency |
| `nestjs` | TypeScript | 3000 | `@nestjs/core` dependency |
| `fastapi` | Python | 8000 | `fastapi` dependency |
| `flask` | Python | 5000 | `flask` dependency |
| `django` | Python | 8000 | `django` dependency |
| `gin` | Go | 8080 | `github.com/gin-gonic/gin` import |
| `echo` | Go | 8080 | `github.com/labstack/echo` import |
| `fiber` | Go | 3000 | `github.com/gofiber/fiber` import |

## Environment Variables

```yaml
functions:
  web:
    src:
      path: ./web
    environment:
      DATABASE_URL: ${{ databases.main.url }}
      REDIS_URL: ${{ databases.cache.url }}
      LOG_LEVEL: ${{ variables.log_level }}
```

## Functions vs Deployments

Choose **functions** when:
- Traffic is sporadic or unpredictable
- You want to scale to zero during idle periods
- Using frameworks like Next.js, Nuxt, or similar
- Cost optimization is important

Choose **deployments** when:
- Traffic is consistent
- You need persistent connections (WebSockets, gRPC streams)
- Cold start latency is unacceptable
- You need more control over resource allocation

## Dynamic Ports

Functions support dynamic port allocation via the `ports` resource, just like deployments.
This is useful when you need a consistent, dynamically allocated port — for example, when
a route targets a function directly and the datacenter needs to discover the upstream port.

```yaml
ports:
  web:
    description: "Web server port"

functions:
  web:
    src:
      path: ./web
      framework: nextjs
    port: ${{ ports.web.port }}
    environment:
      PORT: ${{ ports.web.port }}

routes:
  main:
    type: http
    function: web
```

When a function declares `port`, the value is:
- Used for readiness checks during deployment
- Discoverable by routes that target the function (as `upstream_port` in the datacenter hook)

<Note>
  The `port` property only tells the platform what port the function listens on — it does
  not automatically set the `PORT` environment variable. If your framework reads `PORT` from
  the environment, set it explicitly in the `environment` block.
</Note>

## Complete Example

```yaml
databases:
  main:
    type: postgres:^15

variables:
  log_level:
    default: "info"

functions:
  # Source-based Next.js app (minimal config - everything inferred)
  web:
    src:
      path: ./web
      framework: nextjs
    environment:
      DATABASE_URL: ${{ databases.main.url }}
    memory: "1024Mi"
    timeout: 60

  # Source-based API with explicit config
  api:
    src:
      path: ./api
      language: typescript
      runtime: nodejs20.x
      dev: npm run dev
      start: npm run start
    port: 3001
    environment:
      DATABASE_URL: ${{ databases.main.url }}
    memory: "512Mi"
    timeout: 30

  # Container-based function (legacy or specialized)
  legacy:
    container:
      image: ghcr.io/myorg/legacy-api:v1.0.0
    port: 8080
    memory: "256Mi"

# Routes can point directly to functions - no services needed
routes:
  main:
    type: http
    rules:
      - matches:
          - path:
              type: PathPrefix
              value: /api
        backendRefs:
          - function: api
      - matches:
          - path:
              type: PathPrefix
              value: /
        backendRefs:
          - function: web
```
