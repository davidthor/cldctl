---
title: "Dependencies"
description: "Declare dependencies on other components and access dependent information"
---

# Dependencies

Components can declare dependencies on other components, enabling modular application architectures. Dependencies are automatically deployed and their outputs become available for reference.

## Declaring Dependencies

Dependencies are declared as a simple key-value map where the key is the name you'll use to reference the dependency, and the value is the OCI registry reference (`repo:tag`):

```yaml
dependencies:
  auth: ghcr.io/myorg/auth-service:v1.0.0
  cache: ghcr.io/myorg/redis-cache
```

### Tag Expressions

The tag portion is optional and supports semver version constraints:

| Format | Description | Example |
|--------|-------------|---------|
| `repo:v1.0.0` | Exact version | `ghcr.io/myorg/auth:v1.0.0` |
| `repo:^1` | Compatible with major version 1 | `ghcr.io/myorg/auth:^1` |
| `repo:~1.2` | Compatible with 1.2.x | `ghcr.io/myorg/auth:~1.2` |
| `repo` | Latest version (no tag) | `ghcr.io/myorg/auth` |

## Accessing Dependency Outputs

Reference dependency services, routes, and custom outputs:

```yaml
dependencies:
  auth: ghcr.io/myorg/auth-service:v1.0.0

deployments:
  api:
    image: ${{ builds.api.image }}
    environment:
      AUTH_SERVICE_URL: ${{ dependencies.auth.services.api.url }}
      AUTH_PUBLIC_URL: ${{ dependencies.auth.routes.public.url }}
      AUTH_SECRET: ${{ dependencies.auth.outputs.api_key }}
```

### Available Outputs

| Output | Description |
|--------|-------------|
| `${{ dependencies.<name>.services.<service>.url }}` | Service URL from dependency |
| `${{ dependencies.<name>.services.<service>.host }}` | Service hostname |
| `${{ dependencies.<name>.services.<service>.port }}` | Service port |
| `${{ dependencies.<name>.routes.<route>.url }}` | Route URL from dependency |
| `${{ dependencies.<name>.outputs.<output> }}` | Custom output value from dependency |

## Dependents (Reverse Dependencies)

Access information about components that depend on this component:

```yaml
deployments:
  api:
    environment:
      # Get URLs from all components that depend on this one
      CORS_ORIGINS: ${{ dependents.*.routes.*.url | join "," }}
```

### Wildcard Syntax

Use wildcards to collect values from all dependents:

```yaml
deployments:
  api:
    environment:
      # All route URLs from all dependents
      ALLOWED_ORIGINS: ${{ dependents.*.routes.*.url | join "," }}
      
      # All service URLs from a specific dependent
      FRONTEND_URLS: ${{ dependents.frontend.services.*.url | join "," }}
```

### Specific Dependent

Reference a specific dependent by name:

```yaml
deployments:
  api:
    environment:
      FRONTEND_URL: ${{ dependents.frontend.routes.main.url }}
```

## Optional Dependencies

Dependencies can be marked as optional. Optional dependencies are **not** auto-deployed -- they are only used if already present in the target environment. This is useful for features that enhance a component but are not required for it to function.

To mark a dependency as optional, expand the value from a string to an object with `source` and `optional` fields:

```yaml
dependencies:
  # Required dependency (string shorthand)
  auth: ghcr.io/myorg/auth-service:v1.0.0

  # Optional dependency (object form)
  analytics:
    source: ghcr.io/myorg/analytics:v1
    optional: true
```

When `optional: true`:

- The dependency is **not auto-deployed** when deploying the component
- If the dependency is already deployed in the environment, its outputs are available via `${{ dependencies.<name>.* }}` expressions as usual
- If the dependency is **not** deployed, expressions referencing it resolve to empty values
- Destroying the optional dependency does **not** require `--force` from components that optionally depend on it

### Example

A component that optionally integrates with an analytics service:

```yaml
dependencies:
  analytics:
    source: ghcr.io/myorg/posthog:v1
    optional: true

deployments:
  api:
    image: ${{ builds.api.image }}
    environment:
      # Will be empty if analytics is not deployed
      POSTHOG_API_KEY: ${{ dependencies.analytics.outputs.key }}
```

The application code should handle the case where `POSTHOG_API_KEY` is empty.

## Automatic Deployment

When you deploy a component, cldctl automatically deploys any missing dependencies into the target environment. This recursive resolution means a single `cldctl deploy` or `cldctl up` command brings up an entire application stack -- including all transitive dependencies.

- **Already deployed?** Dependencies that are already present in the environment are skipped.
- **Variables required?** In interactive mode, cldctl prompts for any required variables. In CI or `--auto-approve` mode, missing variables cause a clear error.
- **Transitive?** If a dependency has its own dependencies, those are resolved recursively.

This is the foundation that makes ephemeral environments practical -- one command from zero to a running multi-service application.

<Card title="Automatic Dependency Deployment Guide" icon="diagram-project" href="/guides/components/dependency-deployment">
  In-depth guide on recursive dependency deployment, ephemeral environments, pass-through components, and CI/CD patterns
</Card>

## Dependency Graph

cldctl automatically manages the dependency graph:

1. Dependencies are deployed before dependents
2. Circular dependencies are detected and rejected
3. Updates propagate through the graph
4. **Destroy protection**: You cannot destroy a component if other components in the environment depend on it. cldctl will list the dependents and block the operation. Use `--force` to override this check.

## Complete Example

### Auth Service (Dependency)

```yaml
# auth-service/cld.yml

variables:
  jwt_secret:
    required: true
    sensitive: true

builds:
  api:
    context: ./api

databases:
  users:
    type: postgres:^15

deployments:
  api:
    image: ${{ builds.api.image }}
    environment:
      DATABASE_URL: ${{ databases.users.url }}
      JWT_SECRET: ${{ variables.jwt_secret }}

services:
  api:
    deployment: api
    port: 8080

routes:
  public:
    type: http
    service: api

# Expose outputs for dependents to reference
outputs:
  api_endpoint:
    value: ${{ services.api.url }}
    description: "Internal API endpoint"
```

### Main Application (Dependent)

```yaml
# my-app/cld.yml

dependencies:
  auth: ghcr.io/myorg/auth-service:v1.0.0

variables:
  jwt_secret:
    required: true
    sensitive: true

builds:
  api:
    context: ./api
  frontend:
    context: ./frontend

databases:
  main:
    type: postgres:^15

deployments:
  api:
    image: ${{ builds.api.image }}
    environment:
      DATABASE_URL: ${{ databases.main.url }}
      AUTH_SERVICE_URL: ${{ dependencies.auth.services.api.url }}
      JWT_SECRET: ${{ variables.jwt_secret }}

  frontend:
    image: ${{ builds.frontend.image }}
    environment:
      API_URL: ${{ services.api.url }}
      AUTH_URL: ${{ dependencies.auth.routes.public.url }}

services:
  api:
    deployment: api
    port: 8080

routes:
  main:
    type: http
    service: frontend
```

### Auth Service with CORS (Using Dependents)

```yaml
# auth-service/cld.yml (updated to support CORS)

deployments:
  api:
    image: ${{ builds.api.image }}
    environment:
      DATABASE_URL: ${{ databases.users.url }}
      JWT_SECRET: ${{ variables.jwt_secret }}
      # Automatically allow CORS from all dependent frontends
      CORS_ORIGINS: ${{ dependents.*.routes.*.url | join "," }}
```

## Best Practices

### Version Dependencies

Always use specific versions or semver constraints in production:

```yaml
dependencies:
  # Good - specific version
  auth: ghcr.io/myorg/auth-service:v1.0.0
  
  # Good - semver constraint (allows compatible updates)
  cache: ghcr.io/myorg/redis-cache:^2
  
  # Avoid in production - unpredictable version
  # other: ghcr.io/myorg/other-service
```

### Use Outputs for Shared Configuration

When dependencies need to share sensitive values or complex configuration, use the dependency's outputs rather than passing variables:

```yaml
# In the dependency component (auth-service)
outputs:
  publishable_key:
    value: ${{ variables.clerk_publishable_key }}
    description: "Clerk publishable key for frontend"
  
  secret_key:
    value: ${{ variables.clerk_secret_key }}
    description: "Clerk secret key for backend"
    sensitive: true

# In the dependent component
dependencies:
  auth: ghcr.io/myorg/auth-service:v1.0.0

deployments:
  api:
    environment:
      CLERK_PUBLISHABLE_KEY: ${{ dependencies.auth.outputs.publishable_key }}
      CLERK_SECRET_KEY: ${{ dependencies.auth.outputs.secret_key }}
```
