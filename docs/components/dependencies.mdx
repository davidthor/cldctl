---
title: "Dependencies"
description: "Declare dependencies on other components and access dependent information"
---

# Dependencies

Components can declare dependencies on other components, enabling modular application architectures. Dependencies are automatically deployed and their outputs become available for reference.

## Declaring Dependencies

Dependencies are declared as a simple key-value map where the key is the name you'll use to reference the dependency, and the value is the OCI registry reference (`repo:tag`):

```yaml
dependencies:
  auth: ghcr.io/myorg/auth-service:v1.0.0
  cache: ghcr.io/myorg/redis-cache
```

### Tag Expressions

The tag portion is optional and supports semver version constraints:

| Format | Description | Example |
|--------|-------------|---------|
| `repo:v1.0.0` | Exact version | `ghcr.io/myorg/auth:v1.0.0` |
| `repo:^1` | Compatible with major version 1 | `ghcr.io/myorg/auth:^1` |
| `repo:~1.2` | Compatible with 1.2.x | `ghcr.io/myorg/auth:~1.2` |
| `repo` | Latest version (no tag) | `ghcr.io/myorg/auth` |

## Accessing Dependency Outputs

Reference dependency services, routes, and custom outputs:

```yaml
dependencies:
  auth: ghcr.io/myorg/auth-service:v1.0.0

deployments:
  api:
    image: ${{ builds.api.image }}
    environment:
      AUTH_SERVICE_URL: ${{ dependencies.auth.services.api.url }}
      AUTH_PUBLIC_URL: ${{ dependencies.auth.routes.public.url }}
      AUTH_SECRET: ${{ dependencies.auth.outputs.api_key }}
```

### Available Outputs

| Output | Description |
|--------|-------------|
| `${{ dependencies.<name>.services.<service>.url }}` | Service URL from dependency |
| `${{ dependencies.<name>.services.<service>.host }}` | Service hostname |
| `${{ dependencies.<name>.services.<service>.port }}` | Service port |
| `${{ dependencies.<name>.routes.<route>.url }}` | Route URL from dependency |
| `${{ dependencies.<name>.outputs.<output> }}` | Custom output value from dependency |

## Dependents (Reverse Dependencies)

Access information about components that depend on this component:

```yaml
deployments:
  api:
    environment:
      # Get URLs from all components that depend on this one
      CORS_ORIGINS: ${{ dependents.*.routes.*.url | join "," }}
```

### Wildcard Syntax

Use wildcards to collect values from all dependents:

```yaml
deployments:
  api:
    environment:
      # All route URLs from all dependents
      ALLOWED_ORIGINS: ${{ dependents.*.routes.*.url | join "," }}
      
      # All service URLs from a specific dependent
      FRONTEND_URLS: ${{ dependents.frontend.services.*.url | join "," }}
```

### Specific Dependent

Reference a specific dependent by name:

```yaml
deployments:
  api:
    environment:
      FRONTEND_URL: ${{ dependents.frontend.routes.main.url }}
```

## Dependency Graph

arcctl automatically manages the dependency graph:

1. Dependencies are deployed before dependents
2. Circular dependencies are detected and rejected
3. Updates propagate through the graph

## Complete Example

### Auth Service (Dependency)

```yaml
# auth-service/architect.yml

variables:
  jwt_secret:
    required: true
    sensitive: true

builds:
  api:
    context: ./api

databases:
  users:
    type: postgres:^15

deployments:
  api:
    image: ${{ builds.api.image }}
    environment:
      DATABASE_URL: ${{ databases.users.url }}
      JWT_SECRET: ${{ variables.jwt_secret }}

services:
  api:
    deployment: api
    port: 8080

routes:
  public:
    type: http
    service: api

# Expose outputs for dependents to reference
outputs:
  api_endpoint:
    value: ${{ services.api.url }}
    description: "Internal API endpoint"
```

### Main Application (Dependent)

```yaml
# my-app/architect.yml

dependencies:
  auth: ghcr.io/myorg/auth-service:v1.0.0

variables:
  jwt_secret:
    required: true
    sensitive: true

builds:
  api:
    context: ./api
  frontend:
    context: ./frontend

databases:
  main:
    type: postgres:^15

deployments:
  api:
    image: ${{ builds.api.image }}
    environment:
      DATABASE_URL: ${{ databases.main.url }}
      AUTH_SERVICE_URL: ${{ dependencies.auth.services.api.url }}
      JWT_SECRET: ${{ variables.jwt_secret }}

  frontend:
    image: ${{ builds.frontend.image }}
    environment:
      API_URL: ${{ services.api.url }}
      AUTH_URL: ${{ dependencies.auth.routes.public.url }}

services:
  api:
    deployment: api
    port: 8080

routes:
  main:
    type: http
    service: frontend
```

### Auth Service with CORS (Using Dependents)

```yaml
# auth-service/architect.yml (updated to support CORS)

deployments:
  api:
    image: ${{ builds.api.image }}
    environment:
      DATABASE_URL: ${{ databases.users.url }}
      JWT_SECRET: ${{ variables.jwt_secret }}
      # Automatically allow CORS from all dependent frontends
      CORS_ORIGINS: ${{ dependents.*.routes.*.url | join "," }}
```

## Best Practices

### Version Dependencies

Always use specific versions or semver constraints in production:

```yaml
dependencies:
  # Good - specific version
  auth: ghcr.io/myorg/auth-service:v1.0.0
  
  # Good - semver constraint (allows compatible updates)
  cache: ghcr.io/myorg/redis-cache:^2
  
  # Avoid in production - unpredictable version
  # other: ghcr.io/myorg/other-service
```

### Use Outputs for Shared Configuration

When dependencies need to share sensitive values or complex configuration, use the dependency's outputs rather than passing variables:

```yaml
# In the dependency component (auth-service)
outputs:
  publishable_key:
    value: ${{ variables.clerk_publishable_key }}
    description: "Clerk publishable key for frontend"
  
  secret_key:
    value: ${{ variables.clerk_secret_key }}
    description: "Clerk secret key for backend"
    sensitive: true

# In the dependent component
dependencies:
  auth: ghcr.io/myorg/auth-service:v1.0.0

deployments:
  api:
    environment:
      CLERK_PUBLISHABLE_KEY: ${{ dependencies.auth.outputs.publishable_key }}
      CLERK_SECRET_KEY: ${{ dependencies.auth.outputs.secret_key }}
```
