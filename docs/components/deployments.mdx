---
title: "Deployments"
description: "Define long-running application workloads in arcctl components"
---

# Deployments

Define long-running application workloads. Deployments are containers or processes that run continuously, handling traffic and processing background work.

## Basic Usage

```yaml
builds:
  api:
    context: ./api

deployments:
  api:
    image: ${{ builds.api.image }}
    environment:
      DATABASE_URL: ${{ databases.main.url }}
```

## Properties

| Property | Type | Description |
|----------|------|-------------|
| `image` | string | Container image or `${{ builds.<name>.image }}` expression |
| `runtime` | string or object | Runtime environment for VM/managed deployments (see below) |
| `command` | string[] | Override container command |
| `entrypoint` | string[] | Override container entrypoint |
| `environment` | map | Environment variables (supports expressions) |
| `workingDirectory` | string | Working directory for process-based execution |
| `cpu` | string | CPU allocation |
| `memory` | string | Memory allocation |
| `replicas` | number | Default replica count |
| `liveness_probe` | object | Liveness check configuration |
| `readiness_probe` | object | Readiness check configuration |
| `volumes` | array | Volume mounts |

## Source Configuration

### Use a Top-level Build

Define Docker builds in the top-level `builds` section and reference them via expressions:

```yaml
builds:
  api:
    context: ./api
    dockerfile: Dockerfile          # Optional, defaults to "Dockerfile"
    target: production              # Multi-stage build target
    args:
      NODE_ENV: production

deployments:
  api:
    image: ${{ builds.api.image }}
```

### Use Pre-built Image

```yaml
deployments:
  api:
    image: node:18-alpine
    command: ["npm", "start"]
```

### Process-based (No Image)

For local development, deployments can run directly on the host without Docker:

```yaml
deployments:
  api:
    command: ["npm", "run", "dev"]
    workingDirectory: ./backend  # Optional, defaults to architect.yml directory
```

## Runtime Property

The `runtime` property declares what language and system dependencies a deployment needs to run,
without specifying how they get provisioned. This enables datacenters to provision VMs (e.g., EC2
instances, DigitalOcean Droplets) or managed runtimes for workloads that don't use Docker images.

### Three-Way Routing Model

Datacenters use the presence of `image` and `runtime` to decide how to handle deployments:

- **`image` present** -- container-based (Docker, Kubernetes, ECS, etc.)
- **`runtime` present, no `image`** -- VM-based or managed runtime (EC2, Droplets, etc.)
- **Neither** -- process-based local execution

### String Shorthand

```yaml
deployments:
  worker:
    runtime: node:20
    command: ["node", "dist/worker.js"]
```

### Full Object Form

```yaml
deployments:
  worker:
    runtime:
      language: node:20          # Required. Language and version
      os: linux                  # Optional. Default: linux (linux, windows)
      arch: amd64                # Optional. Default: datacenter's choice (amd64, arm64)
      packages:                  # Optional. System-level dependencies
        - ffmpeg
        - imagemagick
      setup:                     # Optional. Provisioning commands
        - npm ci --production
    command: ["node", "dist/worker.js"]
```

### Runtime Properties

| Property | Type | Required | Description |
|----------|------|----------|-------------|
| `language` | string | Yes | Language runtime with version (e.g., `node:20`, `python:^3.12`, `go:1.22`) |
| `os` | string | No | Target OS. Default: `linux`. Options: `linux`, `windows` |
| `arch` | string | No | Target architecture. Options: `amd64`, `arm64` |
| `packages` | string[] | No | System packages the app depends on (e.g., `ffmpeg`, `libpng-dev`) |
| `setup` | string[] | No | Commands to run during provisioning (e.g., `npm ci --production`) |

## Command and Entrypoint

```yaml
deployments:
  api:
    image: ${{ builds.api.image }}
    command: ["npm", "run", "start:prod"]
    entrypoint: ["/bin/sh", "-c"]
```

### Environment Variables

```yaml
deployments:
  api:
    image: ${{ builds.api.image }}
    environment:
      # Static values
      NODE_ENV: production
      LOG_FORMAT: json
      
      # From databases
      DATABASE_URL: ${{ databases.main.url }}
      REDIS_URL: ${{ databases.cache.url }}
      
      # From variables
      LOG_LEVEL: ${{ variables.log_level }}
      API_KEY: ${{ variables.api_key }}
      
      # From services
      AUTH_SERVICE_URL: ${{ services.auth.url }}
```

## Resource Allocation

```yaml
deployments:
  api:
    image: ${{ builds.api.image }}
    cpu: "0.5"           # 0.5 CPU cores
    memory: "512Mi"      # 512 MB memory
    replicas: 2          # 2 replicas
```

## Health Checks

### Liveness Probe

Determines if the container is running. If it fails, the container is restarted.

```yaml
deployments:
  api:
    image: ${{ builds.api.image }}
    liveness_probe:
      path: /health
      port: 8080
      initial_delay_seconds: 10
      period_seconds: 30
      timeout_seconds: 5
      failure_threshold: 3
```

### Readiness Probe

Determines if the container is ready to receive traffic.

```yaml
deployments:
  api:
    image: ${{ builds.api.image }}
    readiness_probe:
      path: /ready
      port: 8080
      initial_delay_seconds: 5
      period_seconds: 10
```

### TCP Probes

For non-HTTP services:

```yaml
deployments:
  worker:
    image: ${{ builds.worker.image }}
    liveness_probe:
      tcp_socket:
        port: 9000
      period_seconds: 30
```

## Volumes

Mount volumes for persistent data or configuration:

```yaml
deployments:
  api:
    image: ${{ builds.api.image }}
    volumes:
      - mount_path: /data
        host_path: ./data           # For local development
      
      - mount_path: /config
        config_map: app-config      # From ConfigMap
```

## Complete Example

```yaml
builds:
  api:
    context: ./api
    dockerfile: Dockerfile
  worker:
    context: ./worker

databases:
  main:
    type: postgres:^15
  cache:
    type: redis

variables:
  log_level:
    default: "info"

deployments:
  api:
    image: ${{ builds.api.image }}
    command: ["npm", "start"]
    environment:
      NODE_ENV: production
      DATABASE_URL: ${{ databases.main.url }}
      REDIS_URL: ${{ databases.cache.url }}
      LOG_LEVEL: ${{ variables.log_level }}
    cpu: "0.5"
    memory: "512Mi"
    replicas: 2
    liveness_probe:
      path: /health
      port: 8080
      initial_delay_seconds: 10
    readiness_probe:
      path: /ready
      port: 8080

  worker:
    image: ${{ builds.worker.image }}
    environment:
      DATABASE_URL: ${{ databases.main.url }}
      REDIS_URL: ${{ databases.cache.url }}
    cpu: "0.25"
    memory: "256Mi"
    replicas: 1

services:
  api:
    deployment: api
    port: 8080
```

## VM Worker Example (Dev/Prod with Runtime)

```yaml
# architect.yml (dev base)
databases:
  queue:
    type: redis:^7

deployments:
  worker:
    runtime: node:20
    command: ["npx", "tsx", "watch", "src/worker.ts"]
    environment:
      REDIS_URL: ${{ databases.queue.url }}
```

```yaml
# architect.prod.yml (production - runs on VMs)
extends: architect.yml

deployments:
  worker:
    runtime:
      language: node:20
      packages:
        - ffmpeg
      setup:
        - npm ci --production
    command: ["node", "dist/worker.js"]
    cpu: "2"
    memory: "4Gi"
    replicas: 5
```
