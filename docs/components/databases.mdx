---
title: "Databases"
description: "Declare database requirements in cldctl components"
---

# Databases

Declare database requirements for your component. The datacenter determines how databases are provisioned—you just specify what you need.

## Basic Usage

```yaml
databases:
  main:
    type: postgres:^15

  cache:
    type: redis:^7
```

## Properties

| Property | Type | Required | Description |
|----------|------|----------|-------------|
| `type` | string | Yes | Database type with optional semver constraint |
| `migrations` | object | No | Migration/seeding configuration |
| `migrations.image` | string | No | Container image for migrations (e.g., `${{ builds.migrations.image }}`) |
| `migrations.runtime` | string/object | No | Runtime environment for process-based migrations (mutually exclusive with `image`) |
| `migrations.command` | string[] | No | Command to run migrations |
| `migrations.environment` | map | No | Additional environment variables |
| `migrations.workingDirectory` | string | No | Working directory for process-based execution (defaults to component directory) |

## Supported Types

| Type | Description |
|------|-------------|
| `postgres` | PostgreSQL database |
| `mysql` | MySQL database |
| `mariadb` | MariaDB database |
| `mongodb` | MongoDB database |
| `redis` | Redis key-value store |
| `cockroachdb` | CockroachDB distributed SQL |
| `clickhouse` | ClickHouse OLAP database |

## Version Constraints

Use semver constraints to specify compatible versions:

```yaml
databases:
  main:
    type: postgres:^15    # Any 15.x version
  
  legacy:
    type: mysql:~8.0      # 8.0.x only
  
  cache:
    type: redis           # Any version (datacenter default)
```

## Outputs

Access database connection information in other resources:

| Output | Description |
|--------|-------------|
| `${{ databases.<name>.url }}` | Full connection URL |
| `${{ databases.<name>.host }}` | Database hostname |
| `${{ databases.<name>.port }}` | Database port |
| `${{ databases.<name>.database }}` | Database name |
| `${{ databases.<name>.username }}` | Username |
| `${{ databases.<name>.password }}` | Password |

### Read/Write Endpoint Separation

Databases also expose optional `read` and `write` sub-objects for advanced scenarios like zero-downtime migrations where read and write traffic may route to different backends:

| Output | Description |
|--------|-------------|
| `${{ databases.<name>.read.url }}` | Read endpoint connection URL |
| `${{ databases.<name>.read.host }}` | Read endpoint hostname |
| `${{ databases.<name>.read.port }}` | Read endpoint port |
| `${{ databases.<name>.read.username }}` | Read endpoint username |
| `${{ databases.<name>.read.password }}` | Read endpoint password |
| `${{ databases.<name>.write.url }}` | Write endpoint connection URL |
| `${{ databases.<name>.write.host }}` | Write endpoint hostname |
| `${{ databases.<name>.write.port }}` | Write endpoint port |
| `${{ databases.<name>.write.username }}` | Write endpoint username |
| `${{ databases.<name>.write.password }}` | Write endpoint password |

**Fallback behavior**: When the datacenter does not explicitly set `read` or `write` outputs, they automatically mirror the top-level values. This means `${{ databases.main.read.url }}` and `${{ databases.main.write.url }}` always work—even against existing datacenters that only define flat outputs.

### Example Usage

```yaml
deployments:
  api:
    environment:
      DATABASE_URL: ${{ databases.main.url }}
      DB_HOST: ${{ databases.main.host }}
      DB_PORT: ${{ databases.main.port }}
      DB_NAME: ${{ databases.main.database }}
      DB_USER: ${{ databases.main.username }}
      DB_PASS: ${{ databases.main.password }}
```

### Read/Write Endpoint Example

```yaml
deployments:
  api:
    environment:
      # Standard connection (backwards compatible)
      DATABASE_URL: ${{ databases.main.url }}
      # Separate read/write endpoints for migration scenarios
      DATABASE_READ_URL: ${{ databases.main.read.url }}
      DATABASE_WRITE_URL: ${{ databases.main.write.url }}
```

## Database Migrations

Configure automatic migrations that run when the database is provisioned. Migrations support three modes:

### Docker Image (via top-level builds)

Use a top-level `builds` entry and reference its image. This is the recommended approach for production deployments:

```yaml
builds:
  migrations:
    context: ./database/migrations
    dockerfile: Dockerfile

databases:
  main:
    type: postgres:^15
    migrations:
      image: ${{ builds.migrations.image }}
      command: ["npm", "run", "migrate:up"]
      environment:
        MIGRATION_DIR: /migrations
```

### Pre-built Image

```yaml
databases:
  main:
    type: postgres:^15
    migrations:
      image: ghcr.io/myorg/migrations:v1.0.0
      command: ["flyway", "migrate"]
```

### Runtime (Process-based)

Use `runtime` to run migrations as a local process without Docker. Ideal for development:

```yaml
databases:
  main:
    type: postgres:^15
    migrations:
      runtime: node:20
      command: ["npx", "prisma", "migrate", "deploy"]
      environment:
        PRISMA_SCHEMA: ./prisma/schema.prisma
```

### Bare Process (No Image or Runtime)

When neither `image` nor `runtime` is specified, the datacenter decides how to execute. Locally, this runs as a plain process:

```yaml
databases:
  main:
    type: postgres:^15
    migrations:
      command: ["npm", "run", "migrate"]
      workingDirectory: ./database
```

## Complete Example

```yaml
builds:
  api:
    context: ./api
  migrations:
    context: ./database

databases:
  main:
    type: postgres:^15
    migrations:
      image: ${{ builds.migrations.image }}
      command: ["npm", "run", "migrate"]

  cache:
    type: redis:^7

  analytics:
    type: postgres:^15

deployments:
  api:
    image: ${{ builds.api.image }}
    environment:
      DATABASE_URL: ${{ databases.main.url }}
      REDIS_URL: ${{ databases.cache.url }}
      ANALYTICS_DB_URL: ${{ databases.analytics.url }}
```
