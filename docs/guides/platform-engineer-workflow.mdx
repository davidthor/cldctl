---
title: "Platform Engineer Workflow"
description: "The complete DevOps guide to authoring datacenters and managing infrastructure with cldctl"
---

# Platform Engineer Workflow

Welcome to the DevOps guide for cldctl. This is your starting point for learning how to author datacenters, deploy them, provision environments for your developers, and monitor the infrastructure running beneath their applications.

As a platform engineer, you define *how* resources are provisioned so that developers can focus on *what* they need. Your datacenter configuration translates portable component declarations (like `databases.main: postgres:^16`) into real infrastructure (RDS instances, managed databases, Docker containers, etc.).

## Overview

Platform engineers create datacenters that:

1. **Abstract infrastructure complexity** -- Developers don't need to learn IaC
2. **Enforce organizational standards** -- Consistent security, networking, tagging
3. **Enable self-service** -- Developers create environments without platform team involvement
4. **Maintain control** -- Platform team defines how resources are provisioned

## Creating a Datacenter

### Basic Structure

Start with a minimal datacenter:

```hcl
# datacenter.hcl

variable "region" {
  type    = string
  default = "us-east-1"
}

variable "cluster_name" {
  type = string
}

# Shared infrastructure
module "k8s" {
  build = "./modules/k8s-cluster"
  inputs = {
    name   = variable.cluster_name
    region = variable.region
  }
}

# Environment configuration
environment {
  module "namespace" {
    build = "./modules/k8s-namespace"
    inputs = {
      name       = environment.name
      kubeconfig = module.k8s.kubeconfig
    }
  }

  # Resource hooks
  deployment { ... }
  service { ... }
  database { ... }
}
```

### Project Structure

Organize your datacenter project:

```
aws-datacenter/
├── datacenter.hcl              # Main configuration
├── modules/
│   ├── k8s-cluster/            # EKS/GKE cluster module
│   │   ├── Pulumi.yaml
│   │   └── index.ts
│   ├── k8s-namespace/
│   ├── k8s-deployment/
│   ├── k8s-service/
│   ├── rds-postgres/
│   ├── s3-bucket/
│   └── route-rule/
└── vars/
    ├── staging.dcvars
    └── production.dcvars
```

## Implementing Resource Hooks

### Database Hook

Handle database provisioning for components:

```hcl
environment {
  database {
    # Match PostgreSQL requests
    when = element(split(":", node.inputs.type), 0) == "postgres"

    module "rds" {
      build = "./modules/rds-postgres"
      inputs = {
        name            = "${environment.name}-${node.component}-${node.name}"
        instance_class  = "db.t3.micro"    # Can be made configurable
        engine_version  = try(element(split(":", node.inputs.type), 1), null)
        region          = variable.region
        vpc_id          = module.vpc.id
        subnet_ids      = module.vpc.private_subnet_ids
      }
    }

    outputs = {
      host     = module.rds.endpoint
      port     = module.rds.port
      database = module.rds.database_name
      username = module.rds.username
      password = module.rds.password
      url      = module.rds.connection_url
    }
  }

  # Handle Redis separately
  database {
    when = element(split(":", node.inputs.type), 0) == "redis"

    module "elasticache" {
      build = "./modules/elasticache-redis"
      inputs = {
        name    = "${environment.name}-${node.component}-${node.name}"
        region  = variable.region
      }
    }

    outputs = {
      host = module.elasticache.endpoint
      port = module.elasticache.port
      url  = "redis://${module.elasticache.endpoint}:${module.elasticache.port}"
    }
  }
}
```

### Deployment Hook

Handle container deployments. Use `when` conditions to route deployments based on `image` and `runtime`:

```hcl
environment {
  # Container-based deployments (image present)
  deployment {
    when = node.inputs.image != null

    module "k8s_deployment" {
      build = "./modules/k8s-deployment"
      inputs = merge(node.inputs, {
        name       = "${node.component}--${node.name}"
        namespace  = module.namespace.id
        kubeconfig = module.k8s.kubeconfig
        
        # Apply organizational defaults
        resource_limits = {
          cpu    = coalesce(node.inputs.cpu, "500m")
          memory = coalesce(node.inputs.memory, "512Mi")
        }
        
        # Add standard labels
        labels = merge(node.inputs.labels, {
          "app.kubernetes.io/managed-by" = "cldctl"
          "environment"                   = environment.name
          "component"                     = node.component
        })
      })
    }

    outputs = {
      id = module.k8s_deployment.deployment_id
    }
  }

  # VM-based deployments (runtime present, no image)
  deployment {
    when = node.inputs.runtime != null && node.inputs.image == null

    module "vm" {
      plugin = "opentofu"
      build  = "./modules/ec2-vm"
      inputs = merge(node.inputs, {
        name           = "${environment.name}-${node.component}-${node.name}"
        subnet_id      = module.network.subnet_id
        security_group = module.sg.id
      })
    }

    outputs = {
      id = module.vm.instance_id
    }
  }
}
```

### Service Hook

Expose deployments internally:

```hcl
environment {
  service {
    module "k8s_service" {
      build = "./modules/k8s-service"
      inputs = merge(node.inputs, {
        name       = "${node.component}--${node.name}"
        namespace  = module.namespace.id
        kubeconfig = module.k8s.kubeconfig
        selector = {
          app = "${node.component}--${node.inputs.target}"
        }
      })
    }

    outputs = {
      host = module.k8s_service.cluster_ip
      port = module.k8s_service.port
      url  = "http://${module.k8s_service.cluster_ip}:${module.k8s_service.port}"
    }
  }
}
```

### Route Hook

Handle external traffic routing:

```hcl
environment {
  # Create gateway once per environment (if routes exist)
  module "gateway" {
    build = "./modules/gateway"
    when  = length(environment.resources.routes) > 0
    inputs = {
      name       = "${environment.name}-gateway"
      namespace  = module.namespace.id
      kubeconfig = module.k8s.kubeconfig
    }
  }

  route {
    module "route_rule" {
      build = "./modules/route-rule"
      inputs = merge(node.inputs, {
        name          = "${node.component}--${node.name}"
        namespace     = module.namespace.id
        kubeconfig    = module.k8s.kubeconfig
        gateway_name  = module.gateway.name
        domain        = "${environment.name}.${variable.domain}"
      })
    }

    module "dns_record" {
      build = "./modules/dns-record"
      inputs = {
        zone      = variable.dns_zone_id
        name      = "${environment.name}.${variable.domain}"
        type      = "A"
        value     = module.gateway.load_balancer_ip
      }
    }

    outputs = {
      url  = "https://${environment.name}.${variable.domain}"
      host = "${environment.name}.${variable.domain}"
      port = 443
    }
  }
}
```

### Docker Build Hook

Handle local source deployments by building and pushing to registry:

```hcl
environment {
  dockerBuild {
    module "build_and_push" {
      build = "./modules/docker-build-ecr"

      volume {
        host_path  = "/var/run/docker.sock"
        mount_path = "/var/run/docker.sock"
      }

      inputs = merge(node.inputs, {
        # Organize images by environment
        image = "${variable.ecr_registry}/${environment.name}/${node.component}--${node.name}:${node.inputs.hash}"
        
        # ECR authentication
        aws_region     = variable.region
        aws_account_id = variable.aws_account_id
        
        # Create repo if needed
        create_repository = true
      })
    }

    outputs = {
      image = module.build_and_push.image
    }
  }
}
```

## Writing IaC Modules

Modules contain the actual infrastructure code. cldctl supports Pulumi and OpenTofu.

### Pulumi Module Example

```typescript
// modules/k8s-deployment/index.ts
import * as k8s from "@pulumi/kubernetes";
import * as pulumi from "@pulumi/pulumi";

const config = new pulumi.Config();

const name = config.require("name");
const namespace = config.require("namespace");
const image = config.require("image");
const replicas = config.getNumber("replicas") ?? 1;
const environment = config.getObject<Record<string, string>>("environment") ?? {};

const deployment = new k8s.apps.v1.Deployment("deployment", {
  metadata: {
    name: name,
    namespace: namespace,
  },
  spec: {
    replicas: replicas,
    selector: {
      matchLabels: { app: name },
    },
    template: {
      metadata: {
        labels: { app: name },
      },
      spec: {
        containers: [{
          name: name,
          image: image,
          env: Object.entries(environment).map(([k, v]) => ({
            name: k,
            value: v,
          })),
        }],
      },
    },
  },
});

export const deployment_id = deployment.metadata.name;
```

### OpenTofu Module Example

```hcl
# modules/rds-postgres/main.tf

variable "name" {
  type = string
}

variable "instance_class" {
  type    = string
  default = "db.t3.micro"
}

variable "engine_version" {
  type    = string
  default = "15"
}

resource "aws_db_instance" "postgres" {
  identifier           = var.name
  engine               = "postgres"
  engine_version       = var.engine_version
  instance_class       = var.instance_class
  allocated_storage    = 20
  
  db_name  = replace(var.name, "-", "_")
  username = "admin"
  password = random_password.db_password.result
  
  skip_final_snapshot = true
}

resource "random_password" "db_password" {
  length  = 32
  special = false
}

output "endpoint" {
  value = aws_db_instance.postgres.endpoint
}

output "port" {
  value = aws_db_instance.postgres.port
}

output "database_name" {
  value = aws_db_instance.postgres.db_name
}

output "connection_url" {
  value     = "postgresql://${aws_db_instance.postgres.username}:${random_password.db_password.result}@${aws_db_instance.postgres.endpoint}/${aws_db_instance.postgres.db_name}"
  sensitive = true
}
```

## Building and Deploying Datacenters

### Build the Datacenter

```bash
# Build datacenter with all modules
cldctl dc build . -t ghcr.io/myorg/aws-datacenter:v1.0.0

# View what will be built
cldctl dc build . -t ghcr.io/myorg/aws-datacenter:v1.0.0 --dry-run
```

### Push to Registry

```bash
cldctl dc push ghcr.io/myorg/aws-datacenter:v1.0.0
```

### Deploy the Datacenter

```bash
# Deploy with variables
cldctl dc deploy aws-production ghcr.io/myorg/aws-datacenter:v1.0.0 \
  --var cluster_name=prod-cluster \
  --var region=us-east-1 \
  --var domain=prod.example.com

# Deploy with variable file
cldctl dc deploy aws-production ghcr.io/myorg/aws-datacenter:v1.0.0 \
  --var-file ./vars/production.dcvars
```

## Inspecting Running Infrastructure

Once your datacenter is deployed and developers are using it, you need to monitor and inspect the running infrastructure.

### List Deployed Datacenters

See all datacenters you've deployed:

```bash
# List all datacenters
cldctl list datacenter

# Get detailed info about a specific datacenter
cldctl get datacenter aws-production
```

### List Environments

See which environments are running on your datacenters:

```bash
# List all environments
cldctl list environment

# Get details for a specific environment
cldctl get environment staging
```

### Inspect Deployed Components

Drill into what's running inside each environment:

```bash
# List all components in an environment
cldctl list component -e staging

# Get detailed info about a specific component
cldctl get component my-app -e staging
```

The `get component` command shows the component's resource graph, including databases, deployments, services, and routes with their current state and outputs.

### View Logs

Query logs from any environment to diagnose issues:

```bash
# All logs from an environment
cldctl logs -e staging

# Logs from a specific component
cldctl logs -e staging my-app

# Logs from a specific resource type within a component
cldctl logs -e staging my-app/deployment/api

# Stream logs in real-time
cldctl logs -e staging -f

# Logs from the last 5 minutes
cldctl logs -e staging --since 5m
```

### Observability Dashboards

If your datacenter includes an observability hook, open the Grafana dashboard in your browser:

```bash
cldctl observability dashboard -e staging
```

<Tip>
For a comprehensive guide on day-to-day environment management -- creating, updating, inspecting, and destroying environments -- see the [Managing Environments guide](/guides/managing-environments).
</Tip>

## Best Practices

### Security

<AccordionGroup>
  <Accordion title="Use sensitive variables for secrets">
    Mark sensitive variables appropriately:
    ```hcl
    variable "db_password" {
      type      = string
      sensitive = true
    }
    ```
  </Accordion>
  
  <Accordion title="Implement least privilege">
    Create dedicated IAM roles per environment, not shared credentials.
  </Accordion>
  
  <Accordion title="Encrypt sensitive outputs">
    Use secrets managers for sensitive values like database passwords.
  </Accordion>
</AccordionGroup>

### Reliability

<AccordionGroup>
  <Accordion title="Apply organizational defaults">
    Set sensible defaults so developers don't need to specify everything:
    ```hcl
    cpu    = coalesce(node.inputs.cpu, "500m")
    memory = coalesce(node.inputs.memory, "512Mi")
    ```
  </Accordion>
  
  <Accordion title="Add resource limits">
    Enforce resource limits to prevent runaway costs.
  </Accordion>
  
  <Accordion title="Use conditional modules">
    Only create resources when needed:
    ```hcl
    module "gateway" {
      when = length(environment.resources.routes) > 0
    }
    ```
  </Accordion>
</AccordionGroup>

### Maintainability

<AccordionGroup>
  <Accordion title="Version your datacenters">
    Use semantic versioning for datacenter releases.
  </Accordion>
  
  <Accordion title="Test modules independently">
    Test each IaC module before integrating into the datacenter.
  </Accordion>
  
  <Accordion title="Document variables">
    Add descriptions to all variables:
    ```hcl
    variable "cluster_name" {
      description = "Name for the Kubernetes cluster"
      type        = string
    }
    ```
  </Accordion>
</AccordionGroup>

## Next Steps

<CardGroup cols={2}>
  <Card title="Managing Environments" icon="layer-group" href="/guides/managing-environments">
    Day-to-day environment operations
  </Card>
  <Card title="Local Datacenter" icon="docker" href="/guides/datacenters/local">
    Lightweight datacenter for local dev
  </Card>
  <Card title="AWS ECS Datacenter" icon="aws" href="/guides/datacenters/aws-ecs">
    Production datacenter on AWS
  </Card>
  <Card title="Datacenter Reference" icon="server" href="/datacenters/overview">
    Full datacenter specification
  </Card>
</CardGroup>
