---
title: "GCP Cloud Run"
description: "Deploy to GCP Cloud Run with Cloud SQL, GCS, and Cloud Monitoring"
---

# GCP Cloud Run Datacenter

This guide shows how to build a datacenter that deploys components to Google Cloud Run with Cloud SQL for databases, GCS for storage, and Cloud Monitoring for observability. Cloud Run provides a fully serverless experience with automatic scaling and scale-to-zero.

<Info>
This is an officially maintained datacenter template. Source: [`official-templates/gcp-cloud-run/`](https://github.com/davidthor/cldctl/tree/main/official-templates/gcp-cloud-run)
</Info>

## Overview

This datacenter provides:
- **Compute**: Cloud Run services (serverless, scale-to-zero)
- **Databases**: Cloud SQL (PostgreSQL, MySQL), Memorystore (Redis)
- **Storage**: Google Cloud Storage (S3-compatible via HMAC keys)
- **Functions**: Cloud Run with scale-to-zero
- **Networking**: Cloud Load Balancing, Cloud DNS
- **Scheduling**: Cloud Scheduler for cronjobs
- **SMTP**: Configurable external relay (SendGrid, Mailgun, etc.)
- **Observability**: Cloud Monitoring + Cloud Logging + Cloud Trace via OTel

<Warning>
This template does **not** support VM/runtime-based deployments. If your components use the `runtime` property, use [GCP Kubernetes](/guides/datacenters/gcp-k8s) or [GCP VMs](/guides/datacenters/gcp-vms) instead.
</Warning>

## Configuration Variables

```hcl
variable "gcp_project" {
  description = "GCP project ID"
  type        = string
}

variable "gcp_region" {
  description = "GCP region"
  type        = string
  default     = "us-central1"
}

variable "domain" {
  description = "Base domain for environments"
  type        = string
  default     = "app.example.com"
}

variable "registry" {
  description = "Artifact Registry repository URL"
  type        = string
}

variable "smtp_host" {
  description = "External SMTP relay host"
  type        = string
  default     = "smtp.sendgrid.net"
}

variable "smtp_port" {
  description = "External SMTP relay port"
  type        = number
  default     = 587
}

variable "smtp_username" {
  description = "External SMTP relay username"
  type        = string
  default     = "apikey"
}

variable "smtp_password" {
  description = "External SMTP relay password"
  type        = string
  sensitive   = true
  default     = ""
}
```

## Shared Infrastructure

Resources created once and shared across all environments:

```hcl
# VPC for Cloud SQL / Memorystore private connectivity
module "vpc" {
  build = "./modules/gcp-vpc"
  inputs = {
    name    = "${variable.gcp_project}-vpc"
    project = variable.gcp_project
    region  = variable.gcp_region
  }
}

# Serverless VPC connector (Cloud Run â†’ Cloud SQL / Memorystore)
module "vpc_connector" {
  build = "./modules/gcp-vpc-connector"
  inputs = {
    name    = "${variable.gcp_project}-connector"
    project = variable.gcp_project
    region  = variable.gcp_region
    network = module.vpc.network_id
  }
}

# Cloud Load Balancing
module "load_balancer" {
  build = "./modules/gcp-cloud-lb"
  inputs = {
    name    = "${variable.gcp_project}-lb"
    project = variable.gcp_project
    domain  = variable.domain
  }
}
```

The VPC connector is critical for Cloud Run services to access Cloud SQL and Memorystore instances over private networking.

## Environment Configuration

```hcl
environment {
  # Cloud DNS records per environment
  module "dns_records" {
    build = "./modules/gcp-cloud-dns"
    inputs = {
      project   = variable.gcp_project
      zone_name = variable.domain
      subdomain = environment.name
      target    = module.load_balancer.ip_address
    }
  }
}
```

## Resource Hooks

### Database Hook (Cloud SQL + Memorystore)

PostgreSQL and MySQL use Cloud SQL; Redis uses Memorystore:

```hcl
database {
  when = element(split(":", node.inputs.type), 0) == "postgres"

  module "cloud_sql_pg" {
    build = "./modules/gcp-cloud-sql"
    inputs = {
      name          = "${environment.name}-${node.component}-${node.name}"
      project       = variable.gcp_project
      region        = variable.gcp_region
      engine        = "POSTGRES"
      version       = coalesce(try(element(split(":", node.inputs.type), 1), null), "16")
      tier          = "db-f1-micro"
      network       = module.vpc.network_id
      database_name = node.name
    }
  }

  outputs = {
    host     = module.cloud_sql_pg.private_ip
    port     = module.cloud_sql_pg.port
    database = module.cloud_sql_pg.database
    username = module.cloud_sql_pg.username
    password = module.cloud_sql_pg.password
    url      = module.cloud_sql_pg.connection_url
  }
}
```

### Deployment Hook (Cloud Run)

Container-based deployments run on Cloud Run with the VPC connector for database access:

```hcl
deployment {
  when = node.inputs.image != null

  module "cloud_run_service" {
    build = "./modules/gcp-cloud-run-service"
    inputs = merge(node.inputs, {
      name          = "${environment.name}-${node.component}-${node.name}"
      project       = variable.gcp_project
      region        = variable.gcp_region
      vpc_connector = module.vpc_connector.id
    })
  }

  outputs = {
    id = module.cloud_run_service.service_id
  }
}
```

### Function Hook (Cloud Run)

Functions also run on Cloud Run, benefiting from its scale-to-zero capability:

```hcl
function {
  module "cloud_run_function" {
    build = "./modules/gcp-cloud-run-function"
    inputs = merge(node.inputs, {
      name          = "${environment.name}-${node.component}-${node.name}"
      project       = variable.gcp_project
      region        = variable.gcp_region
      vpc_connector = module.vpc_connector.id
    })
  }

  outputs = {
    id       = module.cloud_run_function.service_id
    endpoint = module.cloud_run_function.url
  }
}
```

### Bucket Hook (GCS)

Google Cloud Storage with HMAC keys for S3-compatible access:

```hcl
bucket {
  module "gcs_bucket" {
    build = "./modules/gcp-gcs"
    inputs = {
      name       = "${variable.gcp_project}-${environment.name}-${node.name}"
      project    = variable.gcp_project
      region     = variable.gcp_region
      versioning = node.inputs.versioning
      public     = node.inputs.public
    }
  }

  outputs = {
    endpoint        = "https://storage.googleapis.com"
    bucket          = module.gcs_bucket.bucket_name
    region          = variable.gcp_region
    accessKeyId     = module.gcs_bucket.hmac_access_key
    secretAccessKey = module.gcs_bucket.hmac_secret_key
  }
}
```

### Route Hook (Cloud Load Balancing)

```hcl
route {
  module "lb_backend" {
    build = "./modules/gcp-lb-backend"
    inputs = merge(node.inputs, {
      name          = "${environment.name}-${node.name}"
      project       = variable.gcp_project
      region        = variable.gcp_region
      load_balancer = module.load_balancer.id
      domain        = "${environment.name}.${variable.domain}"
    })
  }

  outputs = {
    url      = "https://${environment.name}.${variable.domain}"
    hosts    = ["${environment.name}.${variable.domain}"]
    protocol = "https"
    host     = "${environment.name}.${variable.domain}"
    port     = 443
  }
}
```

### Cronjob Hook (Cloud Scheduler)

```hcl
cronjob {
  module "cloud_scheduler" {
    build = "./modules/gcp-cloud-scheduler"
    inputs = merge(node.inputs, {
      name    = "${environment.name}-${node.component}-${node.name}"
      project = variable.gcp_project
      region  = variable.gcp_region
    })
  }

  outputs = {
    id = module.cloud_scheduler.job_id
  }
}
```

### Observability Hook (Cloud Monitoring)

```hcl
observability {
  module "gcp_otel" {
    build = "./modules/gcp-otel-collector"
    inputs = {
      name    = "${environment.name}-otel"
      project = variable.gcp_project
      region  = variable.gcp_region
    }
  }

  outputs = {
    endpoint       = module.gcp_otel.otlp_endpoint
    protocol       = "grpc"
    query_type     = "gcp_monitoring"
    query_endpoint = "https://monitoring.googleapis.com/v3/projects/${variable.gcp_project}"
    dashboard_url  = "https://console.cloud.google.com/monitoring/dashboards?project=${variable.gcp_project}"
    attributes = {
      "cloud.provider" = "gcp"
      "cloud.region"   = variable.gcp_region
      "cloud.project"  = variable.gcp_project
    }
  }
}
```

### Docker Build Hook (Artifact Registry)

```hcl
dockerBuild {
  module "artifact_build" {
    build = "./modules/gcp-artifact-build"
    inputs = {
      context    = node.inputs.context
      dockerfile = node.inputs.dockerfile
      target     = node.inputs.target
      args       = node.inputs.args
      registry   = variable.registry
      project    = variable.gcp_project
    }
  }

  outputs = {
    image = module.artifact_build.image_uri
  }
}
```

## Deploying

```bash
# Build the datacenter
cldctl dc build . -t ghcr.io/myorg/gcp-cloud-run-dc:v1.0.0
cldctl dc push ghcr.io/myorg/gcp-cloud-run-dc:v1.0.0

# Deploy with variables
cldctl dc deploy gcp-production \
  --config ghcr.io/myorg/gcp-cloud-run-dc:v1.0.0 \
  --var gcp_project=my-project \
  --var registry=us-central1-docker.pkg.dev/my-project/cldctl \
  --var domain=app.example.com \
  --var smtp_password=$SMTP_PASSWORD

# Create environment and deploy
cldctl env create staging --datacenter gcp-production
cldctl deploy ghcr.io/myorg/my-app:v1.0.0 -e staging
```

## Cost Optimization

- Cloud Run charges per request and compute time (scale-to-zero = no idle cost)
- Use `db-f1-micro` Cloud SQL tier for development environments
- Memorystore Basic tier is more cost-effective for non-critical workloads
- GCS has low storage costs with configurable lifecycle policies
- Cloud Scheduler jobs are free up to 3 per month

## Related Guides

<CardGroup cols={2}>
  <Card title="GCP Kubernetes" href="/guides/datacenters/gcp-k8s">
    GKE-based deployment with Knative and Compute Engine VMs
  </Card>
  <Card title="GCP VMs" href="/guides/datacenters/gcp-vms">
    VM-based deployment using Compute Engine for all workloads
  </Card>
  <Card title="AWS ECS" href="/guides/datacenters/aws-ecs">
    Alternative serverless deployment on AWS
  </Card>
  <Card title="Managing Environments" href="/guides/managing-environments">
    Day-to-day environment operations
  </Card>
</CardGroup>
