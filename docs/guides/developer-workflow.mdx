---
title: "Developer Workflow"
description: "The complete developer guide to building and deploying components with cldctl"
---

# Developer Workflow

Welcome to the developer guide for cldctl. This is your starting point for learning how to author components, iterate locally, build portable artifacts, and deploy to any environment your platform team has provisioned. You don't need to know anything about the underlying infrastructure -- cldctl and your datacenter handle that for you.

## Overview

The typical developer workflow with cldctl:

```mermaid
graph LR
    A[Write Code] --> B[Local Dev]
    B --> C[Build]
    C --> D[Push]
    D --> E[Deploy]
    E --> F[Monitor]
```

1. **Write**: Create your application with an `cloud.component.yml` file
2. **Local Dev**: Use `cldctl up` for rapid iteration
3. **Build**: Build portable OCI artifacts
4. **Push**: Push to a container registry
5. **Deploy**: Deploy to staging/production environments
6. **Monitor**: Track deployments and resources

## Local Development

### Quick Start with `cldctl up`

The fastest way to start developing:

```bash
# Start your application with all dependencies
cldctl up

# With custom variables
cldctl up --var log_level=debug

# Named environment (useful for multiple instances)
cldctl up --name feature-branch
```

`cldctl up` will:
- Parse your `cloud.component.yml`
- Provision databases and other resources locally
- Build your application containers
- Watch for file changes and auto-reload

### Project Structure

A typical cldctl project structure:

```
my-app/
├── cloud.component.yml           # Component definition
├── api/
│   ├── Dockerfile
│   ├── package.json
│   └── src/
├── web/
│   ├── Dockerfile
│   ├── package.json
│   └── src/
├── database/
│   └── migrations/
│       ├── Dockerfile
│       └── migrations/
└── jobs/
    ├── Dockerfile
    └── cleanup.js
```

### Writing Components

Start with a minimal component and add resources as needed:

```yaml
name: my-app

# Start simple
builds:
  api:
    context: ./api

deployments:
  api:
    image: ${{ builds.api.image }}
    environment:
      PORT: "8080"

services:
  api:
    deployment: api
    port: 8080
```

Then add databases when you need persistence:

```yaml
builds:
  api:
    context: ./api

databases:
  main:
    type: postgres:^15

deployments:
  api:
    image: ${{ builds.api.image }}
    environment:
      DATABASE_URL: ${{ databases.main.url }}
      PORT: "8080"
```

### Using Variables

Define configurable inputs for different environments:

```yaml
variables:
  log_level:
    default: "info"
    description: "Application log level"
  
  api_key:
    required: true
    sensitive: true
    description: "External API key"

deployments:
  api:
    environment:
      LOG_LEVEL: ${{ variables.log_level }}
      API_KEY: ${{ variables.api_key }}
```

Set variables during development:

```bash
cldctl up --var log_level=debug --var api_key=dev-key
```

### Working with Dependencies

Reference other components your application needs:

```yaml
dependencies:
  auth:
    component: ghcr.io/myorg/auth:latest
    variables:
      log_level: debug

deployments:
  api:
    environment:
      AUTH_URL: ${{ dependencies.auth.services.api.url }}
```

## Building for Production

### Build Component Artifacts

When ready to share or deploy:

```bash
# Build with version tag
cldctl component build . -t ghcr.io/myorg/my-app:v1.0.0

# Build for specific platform
cldctl component build . -t ghcr.io/myorg/my-app:v1.0.0 --platform linux/amd64

# View what will be built
cldctl component build . -t ghcr.io/myorg/my-app:v1.0.0 --dry-run
```

### Understanding Build Output

Building creates multiple artifacts:

```
Root Artifact:
  ghcr.io/myorg/my-app:v1.0.0

Child Artifacts:
  deployments/api    → ghcr.io/myorg/my-app-deployment-api:v1.0.0
  functions/web      → ghcr.io/myorg/my-app-function-web:v1.0.0
  migrations/main    → ghcr.io/myorg/my-app-migration-main:v1.0.0
```

### Push to Registry

```bash
# Push all artifacts
cldctl component push ghcr.io/myorg/my-app:v1.0.0
```

### Tagging Releases

```bash
# Tag as latest
cldctl component tag ghcr.io/myorg/my-app:v1.0.0 ghcr.io/myorg/my-app:latest

# Tag for production
cldctl component tag ghcr.io/myorg/my-app:v1.0.0 ghcr.io/myorg/my-app:production
```

## Deploying to Environments

### Deploy to Staging

```bash
# Deploy from OCI artifact
cldctl deploy ghcr.io/myorg/my-app:v1.0.0 -e staging \
  --var log_level=debug

# Deploy from local source (for testing)
cldctl deploy ./my-app -e staging \
  --var log_level=debug
```

### View Deployment Status

```bash
# List components in environment
cldctl component list -e staging

# Get detailed component info
cldctl component get my-app -e staging
```

### Update Deployments

```bash
# Deploy new version
cldctl deploy ghcr.io/myorg/my-app:v1.1.0 -e staging
```

cldctl will show a diff of changes:

```
Execution Plan:

  deployment "api"
    ~ update: image ghcr.io/myorg/my-app-deployment-api:v1.0.0
           -> ghcr.io/myorg/my-app-deployment-api:v1.1.0

Plan: 0 to create, 1 to update, 0 to destroy
```

### Rollback

Deploy the previous version:

```bash
cldctl deploy ghcr.io/myorg/my-app:v1.0.0 -e staging
```

## Testing Strategies

### Local Integration Tests

Use `cldctl up` to spin up the full stack for integration tests:

```bash
# Start the environment
cldctl up --name test-env --detach

# Run tests against local environment
npm test

# Cleanup
cldctl env destroy test-env
```

### Preview Environments

Create ephemeral environments for pull request testing:

```bash
# Create preview environment
cldctl env create preview-$PR_NUMBER --datacenter aws-staging --if-not-exists

# Deploy PR build
cldctl deploy ghcr.io/myorg/my-app:pr-$PR_NUMBER -e preview-$PR_NUMBER

# Get preview URL
cldctl env get preview-$PR_NUMBER
```

<Tip>
Automate preview environment creation in your CI pipeline. See the [CI/CD guides](/guides/ci-cd/overview) for GitHub Actions, GitLab CI, and CircleCI examples.
</Tip>

### Promotion Testing

Test in staging before production:

```bash
# Deploy to staging
cldctl deploy ghcr.io/myorg/my-app:v1.1.0 -e staging

# Run smoke tests
./scripts/smoke-test.sh staging

# Promote to production
cldctl deploy ghcr.io/myorg/my-app:v1.1.0 -e production
```

## Best Practices

### Component Design

<AccordionGroup>
  <Accordion title="Keep components focused">
    Each component should represent a single deployable unit. Split large applications into smaller, focused components.
  </Accordion>
  
  <Accordion title="Use semantic versioning">
    Tag component builds with semantic versions (`v1.0.0`, `v1.1.0`) for clear release tracking.
  </Accordion>
  
  <Accordion title="Document variables">
    Add descriptions to all variables so others know what they do:
    ```yaml
    variables:
      stripe_key:
        required: true
        sensitive: true
        description: "Stripe API key for payment processing"
    ```
  </Accordion>
  
  <Accordion title="Use expressions over hardcoding">
    Reference resources via expressions instead of hardcoding values:
    ```yaml
    # Good
    DATABASE_URL: ${{ databases.main.url }}
    
    # Bad
    DATABASE_URL: postgresql://localhost:5432/mydb
    ```
  </Accordion>
</AccordionGroup>

### Development Tips

<AccordionGroup>
  <Accordion title="Use .env files for local variables">
    Create a `.env.local` file for development secrets:
    ```bash
    cldctl up --var-file .env.local
    ```
  </Accordion>
  
  <Accordion title="Leverage health checks">
    Add liveness and readiness probes for reliable deployments:
    ```yaml
    deployments:
      api:
        liveness_probe:
          path: /health
          port: 8080
    ```
  </Accordion>
  
  <Accordion title="Use database migrations">
    Keep database schemas in version control:
    ```yaml
    builds:
      migrations:
        context: ./database/migrations

    databases:
      main:
        type: postgres:^15
        migrations:
          image: ${{ builds.migrations.image }}
          command: ["npm", "run", "migrate"]
    ```
    
    For local development, use `runtime` to run migrations as processes:
    ```yaml
    databases:
      main:
        type: postgres:^15
        migrations:
          runtime: node:20
          command: ["npx", "prisma", "migrate", "deploy"]
    ```
  </Accordion>
</AccordionGroup>

## Troubleshooting

### Common Issues

**Build fails with "Dockerfile not found"**
- Ensure `build.context` points to a directory containing a Dockerfile
- Check `build.dockerfile` if using a custom filename

**Connection refused to database**
- The database might still be starting up
- Check that `DATABASE_URL` expression is correct
- Verify the database type matches what your app expects

**Environment variable not set**
- Ensure the expression syntax is correct: `${{ databases.main.url }}`
- Check that the referenced resource exists in your component

### Getting Help

```bash
# Show command help
cldctl deploy --help

# Verbose output for debugging
cldctl deploy ./my-app -e staging --verbose
```

## Next Steps

<CardGroup cols={2}>
  <Card title="CI/CD Integration" icon="arrows-spin" href="/guides/ci-cd/overview">
    Automate builds and deployments in your pipeline
  </Card>
  <Card title="Next.js with Database & Storage" icon="browsers" href="/guides/components/nextjs-app">
    Full-stack Next.js component example
  </Card>
  <Card title="Microservices Architecture" icon="diagram-project" href="/guides/components/microservices">
    Multi-service system with shared auth
  </Card>
  <Card title="Component Reference" icon="cube" href="/components/overview">
    Full component specification
  </Card>
</CardGroup>
